diff -r f61e52f498ef go/types/call.go
--- a/go/types/call.go
+++ b/go/types/call.go
@@ -238,7 +238,6 @@
 }
 
 func (check *checker) selector(x *operand, e *ast.SelectorExpr) {
-	// these must be declared before the "goto Error" statements
 	var (
 		obj      Object
 		index    []int
@@ -259,7 +258,9 @@
 				if !pkg.pkg.fake {
 					check.errorf(e.Pos(), "%s not declared by package %s", sel, ident)
 				}
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return
 			}
 			if !exp.IsExported() {
 				check.errorf(e.Pos(), "%s not exported by package %s", sel, ident)
@@ -298,7 +299,9 @@
 
 	check.exprOrType(x, e.X)
 	if x.mode == invalid {
-		goto Error
+		x.mode = invalid
+		x.expr = e
+		return
 	}
 
 	obj, index, indirect = LookupFieldOrMethod(x.typ, check.pkg, sel)
@@ -309,7 +312,9 @@
 		} else {
 			check.invalidOp(e.Pos(), "%s has no field or method %s", x, sel)
 		}
-		goto Error
+		x.mode = invalid
+		x.expr = e
+		return
 	}
 
 	if x.mode == typexpr {
@@ -317,13 +322,17 @@
 		m, _ := obj.(*Func)
 		if m == nil {
 			check.invalidOp(e.Pos(), "%s has no method %s", x, sel)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return
 		}
 
 		// verify that m is in the method set of x.typ
 		if !indirect && ptrRecv(m) {
 			check.invalidOp(e.Pos(), "%s is not in method set of %s", sel, x.typ)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return
 		}
 
 		check.recordSelection(e, MethodExpr, x.typ, m, index, indirect)
@@ -366,7 +375,9 @@
 			//        is shorthand for (&x).m()".
 			if !indirect && x.mode != variable && ptrRecv(obj) {
 				check.invalidOp(e.Pos(), "%s is not in method set of %s", sel, x)
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return
 			}
 
 			check.recordSelection(e, MethodVal, x.typ, obj, index, indirect)
@@ -414,9 +425,4 @@
 
 	// everything went well
 	x.expr = e
-	return
-
-Error:
-	x.mode = invalid
-	x.expr = e
 }
diff -r f61e52f498ef go/types/expr.go
--- a/go/types/expr.go
+++ b/go/types/expr.go
@@ -481,7 +481,9 @@
 				check.updateExprType(x.expr, target, false)
 			}
 		} else if xkind != tkind {
-			goto Error
+			check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+			x.mode = invalid
+			return
 		}
 		return
 	}
@@ -502,11 +504,15 @@
 			switch x.typ.(*Basic).kind {
 			case UntypedBool:
 				if !isBoolean(target) {
-					goto Error
+					check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+					x.mode = invalid
+					return
 				}
 			case UntypedInt, UntypedRune, UntypedFloat, UntypedComplex:
 				if !isNumeric(target) {
-					goto Error
+					check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+					x.mode = invalid
+					return
 				}
 			case UntypedString:
 				// Non-constant untyped string values are not
@@ -515,15 +521,21 @@
 			case UntypedNil:
 				// Unsafe.Pointer is a basic type that includes nil.
 				if !hasNil(target) {
-					goto Error
+					check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+					x.mode = invalid
+					return
 				}
 			default:
-				goto Error
+				check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+				x.mode = invalid
+				return
 			}
 		}
 	case *Interface:
 		if !x.isNil() && !t.Empty() /* empty interfaces are ok */ {
-			goto Error
+			check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+			x.mode = invalid
+			return
 		}
 		// Update operand types to the default type rather then
 		// the target (interface) type: values must have concrete
@@ -536,27 +548,28 @@
 		} else {
 			// cannot assign untyped values to non-empty interfaces
 			if !t.Empty() {
-				goto Error
+				check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+				x.mode = invalid
+				return
 			}
 			target = defaultType(x.typ)
 		}
 	case *Pointer, *Signature, *Slice, *Map, *Chan:
 		if !x.isNil() {
-			goto Error
+			check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+			x.mode = invalid
+			return
 		}
 		// keep nil untyped - see comment for interfaces, above
 		target = Typ[UntypedNil]
 	default:
-		goto Error
+		check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+		x.mode = invalid
+		return
 	}
 
 	x.typ = target
 	check.updateExprType(x.expr, target, true) // UntypedNils are final
-	return
-
-Error:
-	check.errorf(x.pos(), "cannot convert %s to %s", x, target)
-	x.mode = invalid
 }
 
 func (check *checker) comparison(x, y *operand, op token.Token) {
@@ -941,7 +954,9 @@
 
 	switch e := e.(type) {
 	case *ast.BadExpr:
-		goto Error // error was reported before
+		x.mode = invalid
+		x.expr = e
+		return statement // error was reported before
 
 	case *ast.Ident:
 		check.ident(x, e, nil, false)
@@ -950,13 +965,17 @@
 		// ellipses are handled explicitly where they are legal
 		// (array composite literals and parameter lists)
 		check.errorf(e.Pos(), "invalid use of '...'")
-		goto Error
+		x.mode = invalid
+		x.expr = e
+		return statement
 
 	case *ast.BasicLit:
 		x.setConst(e.Kind, e.Value)
 		if x.mode == invalid {
 			check.invalidAST(e.Pos(), "invalid literal %v", e.Value)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 	case *ast.FuncLit:
@@ -969,7 +988,9 @@
 			x.typ = sig
 		} else {
 			check.invalidAST(e.Pos(), "invalid function literal %s", e)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 	case *ast.CompositeLit:
@@ -994,7 +1015,9 @@
 		}
 		if typ == nil {
 			check.errorf(e.Pos(), "missing type in composite literal")
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		switch typ, _ := deref(typ); utyp := typ.Underlying().(type) {
@@ -1109,7 +1132,9 @@
 
 		default:
 			check.errorf(e.Pos(), "invalid composite literal type %s", typ)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		x.mode = value
@@ -1126,7 +1151,9 @@
 	case *ast.IndexExpr:
 		check.expr(x, e.X)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		valid := false
@@ -1173,7 +1200,9 @@
 				if key.mode != invalid {
 					check.invalidOp(key.pos(), "cannot use %s as map index of type %s", &key, typ.key)
 				}
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return statement
 			}
 			x.mode = mapindex
 			x.typ = typ.elem
@@ -1183,12 +1212,16 @@
 
 		if !valid {
 			check.invalidOp(x.pos(), "cannot index %s", x)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		if e.Index == nil {
 			check.invalidAST(e.Pos(), "missing index for %s", x)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		check.index(e.Index, length)
@@ -1197,7 +1230,9 @@
 	case *ast.SliceExpr:
 		check.expr(x, e.X)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		valid := false
@@ -1207,7 +1242,9 @@
 			if isString(typ) {
 				if slice3(e) {
 					check.invalidOp(x.pos(), "3-index slice of string")
-					goto Error
+					x.mode = invalid
+					x.expr = e
+					return statement
 				}
 				valid = true
 				if x.mode == constant {
@@ -1226,7 +1263,9 @@
 			length = typ.len
 			if x.mode != variable {
 				check.invalidOp(x.pos(), "cannot slice %s (value not addressable)", x)
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return statement
 			}
 			x.typ = &Slice{elem: typ.elem}
 
@@ -1246,13 +1285,17 @@
 
 		if !valid {
 			check.invalidOp(x.pos(), "cannot slice %s", x)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		// spec: "Only the first index may be omitted; it defaults to 0."
 		if slice3(e) && (e.High == nil || sliceMax(e) == nil) {
 			check.errorf(e.Rbrack, "2nd and 3rd index required in 3-index slice")
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		// check indices
@@ -1298,21 +1341,29 @@
 	case *ast.TypeAssertExpr:
 		check.expr(x, e.X)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		xtyp, _ := x.typ.Underlying().(*Interface)
 		if xtyp == nil {
 			check.invalidOp(x.pos(), "%s is not an interface", x)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		// x.(type) expressions are handled explicitly in type switches
 		if e.Type == nil {
 			check.invalidAST(e.Pos(), "use of .(type) outside type switch")
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		T := check.typ(e.Type, nil, false)
 		if T == Typ[Invalid] {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		check.typeAssertion(x.pos(), x, xtyp, T)
 		x.mode = commaok
@@ -1325,7 +1376,9 @@
 		check.exprOrType(x, e.X)
 		switch x.mode {
 		case invalid:
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		case typexpr:
 			x.typ = &Pointer{base: x.typ}
 		default:
@@ -1334,18 +1387,24 @@
 				x.typ = typ.base
 			} else {
 				check.invalidOp(x.pos(), "cannot indirect %s", x)
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return statement
 			}
 		}
 
 	case *ast.UnaryExpr:
 		check.expr(x, e.X)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		check.unary(x, e.Op)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		if e.Op == token.ARROW {
 			x.expr = e
@@ -1355,13 +1414,17 @@
 	case *ast.BinaryExpr:
 		check.binary(x, e.X, e.Y, e.Op)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 	case *ast.KeyValueExpr:
 		// key:value expressions are handled in composite literals
 		check.invalidAST(e.Pos(), "no key:value expected")
-		goto Error
+		x.mode = invalid
+		x.expr = e
+		return statement
 
 	case *ast.ArrayType, *ast.StructType, *ast.FuncType,
 		*ast.InterfaceType, *ast.MapType, *ast.ChanType:
@@ -1383,11 +1446,6 @@
 	// everything went well
 	x.expr = e
 	return expression
-
-Error:
-	x.mode = invalid
-	x.expr = e
-	return statement // avoid follow-up errors
 }
 
 // typeAssertion checks that x.(T) is legal; xtyp must be the type of x.
