0ÉÊHtext/template/parseÇ2Wpackage parse
import list "container/list"
import fmt "fmt"
import strings "strings"
import unicode "unicode"
import utf8 "unicode/utf8"
import bytes "bytes"
import strconv "strconv"
import runtime "runtime"
type @"".ActionNode struct { ? @"".NodeType; ? @"".Pos; @"".Line int; @"".Pipe *@"".PipeNode }
func (? *@"".ActionNode) @"".Copy() (? @"".Node)
func (? *@"".ActionNode) @"".String() (? string)
type @"".BoolNode struct { ? @"".NodeType; ? @"".Pos; @"".True bool }
func (? *@"".BoolNode) @"".Copy() (? @"".Node)
func (? *@"".BoolNode) @"".String() (? string)
type @"".BranchNode struct { ? @"".NodeType; ? @"".Pos; @"".Line int; @"".Pipe *@"".PipeNode; @"".List *@"".ListNode; @"".ElseList *@"".ListNode }
func (? *@"".BranchNode) @"".String() (? string)
type @"".ChainNode struct { ? @"".NodeType; ? @"".Pos; @"".Node @"".Node; @"".Field []string }
func (? *@"".ChainNode) @"".Add(@"".field string) ()
func (? *@"".ChainNode) @"".Copy() (? @"".Node)
func (? *@"".ChainNode) @"".String() (? string)
type @"".CommandNode struct { ? @"".NodeType; ? @"".Pos; @"".Args []@"".Node }
func (? *@"".CommandNode) @"".Copy() (? @"".Node)
func (? *@"".CommandNode) @"".String() (? string)
func (? *@"".CommandNode) @"".append(@"".arg @"".Node) ()
type @"".DotNode struct { ? @"".Pos }
func (? *@"".DotNode) @"".Copy() (? @"".Node)
func (? *@"".DotNode) @"".String() (? string)
func (? *@"".DotNode) @"".Type() (? @"".NodeType)
type @"".FieldNode struct { ? @"".NodeType; ? @"".Pos; @"".Ident []string }
func (? *@"".FieldNode) @"".Copy() (? @"".Node)
func (? *@"".FieldNode) @"".String() (? string)
type @"".IdentifierNode struct { ? @"".NodeType; ? @"".Pos; @"".Ident string }
func (? *@"".IdentifierNode) @"".Copy() (? @"".Node)
func (? *@"".IdentifierNode) @"".SetPos(@"".pos @"".Pos) (? *@"".IdentifierNode)
func (? *@"".IdentifierNode) @"".String() (? string)
type @"".IfNode struct { ? @"".BranchNode }
func (? *@"".IfNode) @"".Copy() (? @"".Node)
func @"".IsEmptyTree(@"".n @"".Node) (? bool)
type @"".ListNode struct { ? @"".NodeType; ? @"".Pos; @"".Nodes []@"".Node }
func (? *@"".ListNode) @"".Copy() (? @"".Node)
func (? *@"".ListNode) @"".CopyList() (? *@"".ListNode)
func (? *@"".ListNode) @"".String() (? string)
func (? *@"".ListNode) @"".append(@"".n @"".Node) ()
func @"".New(@"".name string, @"".funcs ...map[string]interface {  }) (? *@"".Tree)
func @"".NewIdentifier(@"".ident string) (? *@"".IdentifierNode)
type @"".NilNode struct { ? @"".Pos }
func (? *@"".NilNode) @"".Copy() (? @"".Node)
func (? *@"".NilNode) @"".String() (? string)
func (? *@"".NilNode) @"".Type() (? @"".NodeType)
type @"".Node interface { @"".Copy() (? @"".Node); @"".Position() (? @"".Pos); @"".String() (? string); @"".Type() (? @"".NodeType); @"".unexported() () }
const @"".NodeAction @"".NodeType = 0x1
const @"".NodeBool @"".NodeType = 0x2
const @"".NodeChain @"".NodeType = 0x3
const @"".NodeCommand @"".NodeType = 0x4
const @"".NodeDot @"".NodeType = 0x5
const @"".NodeField @"".NodeType = 0x8
const @"".NodeIdentifier @"".NodeType = 0x9
const @"".NodeIf @"".NodeType = 0xa
const @"".NodeList @"".NodeType = 0xb
const @"".NodeNil @"".NodeType = 0xc
const @"".NodeNumber @"".NodeType = 0xd
const @"".NodePipe @"".NodeType = 0xe
const @"".NodeRange @"".NodeType = 0xf
const @"".NodeString @"".NodeType = 0x10
const @"".NodeTemplate @"".NodeType = 0x11
const @"".NodeText @"".NodeType = 0x0
type @"".NodeType int
func (? @"".NodeType) @"".Type() (? @"".NodeType)
func (? *@"".NodeType) @"".Type() (? @"".NodeType)
const @"".NodeVariable @"".NodeType = 0x12
const @"".NodeWith @"".NodeType = 0x13
type @"".NumberNode struct { ? @"".NodeType; ? @"".Pos; @"".IsInt bool; @"".IsUint bool; @"".IsFloat bool; @"".IsComplex bool; @"".Int64 int64; @"".Uint64 uint64; @"".Float64 float64; @"".Complex128 complex128; @"".Text string }
func (? *@"".NumberNode) @"".Copy() (? @"".Node)
func (? *@"".NumberNode) @"".String() (? string)
func (? *@"".NumberNode) @"".simplifyComplex() ()
func @"".Parse(@"".name string, @"".text string, @"".leftDelim string, @"".rightDelim string, @"".funcs ...map[string]interface {  }) (@"".treeSet map[string]*@"".Tree, @"".err error)
type @"".PipeNode struct { ? @"".NodeType; ? @"".Pos; @"".Line int; @"".Decl []*@"".VariableNode; @"".Cmds []*@"".CommandNode }
func (? *@"".PipeNode) @"".Copy() (? @"".Node)
func (? *@"".PipeNode) @"".CopyPipe() (? *@"".PipeNode)
func (? *@"".PipeNode) @"".String() (? string)
func (? *@"".PipeNode) @"".append(@"".command *@"".CommandNode) ()
type @"".Pos int
func (? @"".Pos) @"".Position() (? @"".Pos)
func (? @"".Pos) @"".unexported() ()
func (? *@"".Pos) @"".Position() (? @"".Pos)
func (? *@"".Pos) @"".unexported() ()
type @"".RangeNode struct { ? @"".BranchNode }
func (? *@"".RangeNode) @"".Copy() (? @"".Node)
type @"".StringNode struct { ? @"".NodeType; ? @"".Pos; @"".Quoted string; @"".Text string }
func (? *@"".StringNode) @"".Copy() (? @"".Node)
func (? *@"".StringNode) @"".String() (? string)
type @"".TemplateNode struct { ? @"".NodeType; ? @"".Pos; @"".Line int; @"".Name string; @"".Pipe *@"".PipeNode }
func (? *@"".TemplateNode) @"".Copy() (? @"".Node)
func (? *@"".TemplateNode) @"".String() (? string)
type @"".TextNode struct { ? @"".NodeType; ? @"".Pos; @"".Text []byte }
func (? *@"".TextNode) @"".Copy() (? @"".Node)
func (? *@"".TextNode) @"".String() (? string)
type @"".Tree struct { @"".Name string; @"".ParseName string; @"".Root *@"".ListNode; @"".text string; @"".funcs []map[string]interface {  }; @"".lex *@"".lexer; @"".token [3]@"".item; @"".peekCount int; @"".vars []string }
func (? *@"".Tree) @"".Copy() (? *@"".Tree)
func (? *@"".Tree) @"".ErrorContext(@"".n @"".Node) (@"".location string, @"".context string)
func (? *@"".Tree) @"".Parse(@"".text string, @"".leftDelim string, @"".rightDelim string, @"".treeSet map[string]*@"".Tree, @"".funcs ...map[string]interface {  }) (@"".tree *@"".Tree, @"".err error)
func (? *@"".Tree) @"".action() (@"".n @"".Node)
func (? *@"".Tree) @"".add(@"".treeSet map[string]*@"".Tree) ()
func (? *@"".Tree) @"".backup() ()
func (? *@"".Tree) @"".backup2(@"".t1 @"".item) ()
func (? *@"".Tree) @"".backup3(@"".t2 @"".item, @"".t1 @"".item) ()
func (? *@"".Tree) @"".command() (? *@"".CommandNode)
func (? *@"".Tree) @"".elseControl() (? @"".Node)
func (? *@"".Tree) @"".endControl() (? @"".Node)
func (? *@"".Tree) @"".error(@"".err error) ()
func (? *@"".Tree) @"".errorf(@"".format string, @"".args ...interface {  }) ()
func (? *@"".Tree) @"".expect(@"".expected @"".itemType, @"".context string) (? @"".item)
func (? *@"".Tree) @"".expectOneOf(@"".expected1 @"".itemType, @"".expected2 @"".itemType, @"".context string) (? @"".item)
func (? *@"".Tree) @"".hasFunction(@"".name string) (? bool)
func (? *@"".Tree) @"".ifControl() (? @"".Node)
func (? *@"".Tree) @"".itemList() (@"".list *@"".ListNode, @"".next @"".Node)
func (? *@"".Tree) @"".next() (? @"".item)
func (? *@"".Tree) @"".nextNonSpace() (@"".token @"".item)
func (? *@"".Tree) @"".operand() (? @"".Node)
func (? *@"".Tree) @"".parse(@"".treeSet map[string]*@"".Tree) (@"".next @"".Node)
func (? *@"".Tree) @"".parseControl(@"".allowElseIf bool, @"".context string) (@"".pos @"".Pos, @"".line int, @"".pipe *@"".PipeNode, @"".list *@"".ListNode, @"".elseList *@"".ListNode)
func (? *@"".Tree) @"".parseDefinition(@"".treeSet map[string]*@"".Tree) ()
func (? *@"".Tree) @"".peek() (? @"".item)
func (? *@"".Tree) @"".peekNonSpace() (@"".token @"".item)
func (? *@"".Tree) @"".pipeline(@"".context string) (@"".pipe *@"".PipeNode)
func (? *@"".Tree) @"".popVars(@"".n int) ()
func (? *@"".Tree) @"".rangeControl() (? @"".Node)
func (? *@"".Tree) @"".recover(@"".errp *error) ()
func (? *@"".Tree) @"".startParse(@"".funcs []map[string]interface {  }, @"".lex *@"".lexer) ()
func (? *@"".Tree) @"".stopParse() ()
func (? *@"".Tree) @"".templateControl() (? @"".Node)
func (? *@"".Tree) @"".term() (? @"".Node)
func (? *@"".Tree) @"".textOrAction() (? @"".Node)
func (? *@"".Tree) @"".unexpected(@"".token @"".item, @"".context string) ()
func (? *@"".Tree) @"".useVar(@"".pos @"".Pos, @"".name string) (? @"".Node)
func (? *@"".Tree) @"".withControl() (? @"".Node)
type @"".VariableNode struct { ? @"".NodeType; ? @"".Pos; @"".Ident []string }
func (? *@"".VariableNode) @"".Copy() (? @"".Node)
func (? *@"".VariableNode) @"".String() (? string)
type @"".WithNode struct { ? @"".BranchNode }
func (? *@"".WithNode) @"".Copy() (? @"".Node)
type @"".elseNode struct { ? @"".NodeType; ? @"".Pos; @"".Line int }
func (? *@"".elseNode) @"".Copy() (? @"".Node)
func (? *@"".elseNode) @"".String() (? string)
func (? *@"".elseNode) @"".Type() (? @"".NodeType)
type @"".endNode struct { ? @"".Pos }
func (? *@"".endNode) @"".Copy() (? @"".Node)
func (? *@"".endNode) @"".String() (? string)
func (? *@"".endNode) @"".Type() (? @"".NodeType)
type @"".item struct { @"".typ @"".itemType; @"".pos @"".Pos; @"".val string }
func (? @"".item) @"".String() (? string)
func (? *@"".item) @"".String() (? string)
type @"".itemType int
type @"".lexer struct { @"".name string; @"".input string; @"".leftDelim string; @"".rightDelim string; @"".state @"".stateFn; @"".pos @"".Pos; @"".start @"".Pos; @"".width @"".Pos; @"".lastPos @"".Pos; @"".items *@"container/list".List; @"".parenDepth int }
func (? *@"".lexer) @"".accept(@"".valid string) (? bool)
func (? *@"".lexer) @"".acceptRun(@"".valid string) ()
func (? *@"".lexer) @"".atTerminator() (? bool)
func (? *@"".lexer) @"".backup() ()
func (? *@"".lexer) @"".emit(@"".t @"".itemType) ()
func (? *@"".lexer) @"".errorf(@"".format string, @"".args ...interface {  }) (? @"".stateFn)
func (? *@"".lexer) @"".ignore() ()
func (? *@"".lexer) @"".lineNumber() (? int)
func (? *@"".lexer) @"".next() (? rune)
func (? *@"".lexer) @"".nextItem() (? @"".item)
func (? *@"".lexer) @"".peek() (? rune)
func (? *@"".lexer) @"".scanNumber() (? bool)
type @"".stateFn func (? *@"".lexer) (? @"".stateFn)
type @"container/list".List struct { @"container/list".root @"container/list".Element; @"container/list".len int }
func (? *@"container/list".List) @"container/list".Back() (? *@"container/list".Element)
func (? *@"container/list".List) @"container/list".Front() (? *@"container/list".Element)
func (? *@"container/list".List) @"container/list".Init() (? *@"container/list".List)
func (? *@"container/list".List) @"container/list".InsertAfter(@"container/list".v interface {  }, @"container/list".mark *@"container/list".Element) (? *@"container/list".Element)
func (? *@"container/list".List) @"container/list".InsertBefore(@"container/list".v interface {  }, @"container/list".mark *@"container/list".Element) (? *@"container/list".Element)
func (? *@"container/list".List) @"container/list".Len() (? int)
func (? *@"container/list".List) @"container/list".MoveAfter(@"container/list".e *@"container/list".Element, @"container/list".mark *@"container/list".Element) ()
func (? *@"container/list".List) @"container/list".MoveBefore(@"container/list".e *@"container/list".Element, @"container/list".mark *@"container/list".Element) ()
func (? *@"container/list".List) @"container/list".MoveToBack(@"container/list".e *@"container/list".Element) ()
func (? *@"container/list".List) @"container/list".MoveToFront(@"container/list".e *@"container/list".Element) ()
func (? *@"container/list".List) @"container/list".PushBack(@"container/list".v interface {  }) (? *@"container/list".Element)
func (? *@"container/list".List) @"container/list".PushBackList(@"container/list".other *@"container/list".List) ()
func (? *@"container/list".List) @"container/list".PushFront(@"container/list".v interface {  }) (? *@"container/list".Element)
func (? *@"container/list".List) @"container/list".PushFrontList(@"container/list".other *@"container/list".List) ()
func (? *@"container/list".List) @"container/list".Remove(@"container/list".e *@"container/list".Element) (? interface {  })
func (? *@"container/list".List) @"container/list".insert(@"container/list".e *@"container/list".Element, @"container/list".at *@"container/list".Element) (? *@"container/list".Element)
func (? *@"container/list".List) @"container/list".insertValue(@"container/list".v interface {  }, @"container/list".at *@"container/list".Element) (? *@"container/list".Element)
func (? *@"container/list".List) @"container/list".lazyInit() ()
func (? *@"container/list".List) @"container/list".remove(@"container/list".e *@"container/list".Element) (? *@"container/list".Element)
type @"container/list".Element struct { @"container/list".next *@"container/list".Element; @"container/list".prev *@"container/list".Element; @"container/list".list *@"container/list".List; @"container/list".Value interface {  } }
func (? *@"container/list".Element) @"container/list".Next() (? *@"container/list".Element)
func (? *@"container/list".Element) @"container/list".Prev() (? *@"container/list".Element)
$$
0Å§runtimeerrorssync/atomicsynciounicodeunicode/utf8bytescontainer/listmathsyscalltimeosstrconvreflectfmtstringstext/template/parse0Åö0container/listlist0
fmtfmt0stringsstrings0unicodeunicode0unicode/utf8utf80bytesbytes0strconvstrconv0runtimeruntime0É≤ç0Ç£itemÇ	item = go$pkg.item = go$newType(0, "Struct", "parse.item", "item", "text/template/parse", function(typ_, pos_, val_) {
		this.go$val = this;
		this.typ = typ_ !== undefined ? typ_ : 0;
		this.pos = pos_ !== undefined ? pos_ : 0;
		this.val = val_ !== undefined ? val_ : "";
	});
Ç6		item.methods = [["String", "", [], [Go$String], false, -1]];
		(go$ptrType(item)).methods = [["String", "", [], [Go$String], false, -1]];
		item.init([["typ", "typ", "text/template/parse", itemType, ""], ["pos", "pos", "text/template/parse", Pos, ""], ["val", "val", "text/template/parse", Go$String, ""]]);
0item0=0text/template/parseitemType0text/template/parsePos0ÅãitemTypeo	itemType = go$pkg.itemType = go$newType(4, "Int", "parse.itemType", "itemType", "text/template/parse", null);
 0
itemType0 0Å›stateFnl	stateFn = go$pkg.stateFn = go$newType(0, "Func", "parse.stateFn", "stateFn", "text/template/parse", null);
9		stateFn.init([(go$ptrType(lexer))], [stateFn], false);
0	stateFn00text/template/parselexer0Ç	„lexerÇk	lexer = go$pkg.lexer = go$newType(0, "Struct", "parse.lexer", "lexer", "text/template/parse", function(name_, input_, leftDelim_, rightDelim_, state_, pos_, start_, width_, lastPos_, items_, parenDepth_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : "";
		this.input = input_ !== undefined ? input_ : "";
		this.leftDelim = leftDelim_ !== undefined ? leftDelim_ : "";
		this.rightDelim = rightDelim_ !== undefined ? rightDelim_ : "";
		this.state = state_ !== undefined ? state_ : go$throwNilPointerError;
		this.pos = pos_ !== undefined ? pos_ : 0;
		this.start = start_ !== undefined ? start_ : 0;
		this.width = width_ !== undefined ? width_ : 0;
		this.lastPos = lastPos_ !== undefined ? lastPos_ : 0;
		this.items = items_ !== undefined ? items_ : (go$ptrType(list.List)).nil;
		this.parenDepth = parenDepth_ !== undefined ? parenDepth_ : 0;
	});
ÇÀ		(go$ptrType(lexer)).methods = [["accept", "text/template/parse", [Go$String], [Go$Bool], false, -1], ["acceptRun", "text/template/parse", [Go$String], [], false, -1], ["atTerminator", "text/template/parse", [], [Go$Bool], false, -1], ["backup", "text/template/parse", [], [], false, -1], ["emit", "text/template/parse", [itemType], [], false, -1], ["errorf", "text/template/parse", [Go$String, (go$sliceType(go$emptyInterface))], [stateFn], true, -1], ["ignore", "text/template/parse", [], [], false, -1], ["lineNumber", "text/template/parse", [], [Go$Int], false, -1], ["next", "text/template/parse", [], [Go$Int32], false, -1], ["nextItem", "text/template/parse", [], [item], false, -1], ["peek", "text/template/parse", [], [Go$Int32], false, -1], ["scanNumber", "text/template/parse", [], [Go$Bool], false, -1]];
		lexer.init([["name", "name", "text/template/parse", Go$String, ""], ["input", "input", "text/template/parse", Go$String, ""], ["leftDelim", "leftDelim", "text/template/parse", Go$String, ""], ["rightDelim", "rightDelim", "text/template/parse", Go$String, ""], ["state", "state", "text/template/parse", stateFn, ""], ["pos", "pos", "text/template/parse", Pos, ""], ["start", "start", "text/template/parse", Pos, ""], ["width", "width", "text/template/parse", Pos, ""], ["lastPos", "lastPos", "text/template/parse", Pos, ""], ["items", "items", "text/template/parse", (go$ptrType(list.List)), ""], ["parenDepth", "parenDepth", "text/template/parse", Go$Int, ""]]);
0lexer0Åí0container/listList0text/template/parseitemType0text/template/parsestateFn0text/template/parseitem0text/template/parsePos0Ç⁄Nodee	Node = go$pkg.Node = go$newType(0, "Interface", "parse.Node", "Node", "text/template/parse", null);
Ç"		Node.init([["Copy", "", (go$funcType([], [Node], false))], ["Position", "", (go$funcType([], [Pos], false))], ["String", "", (go$funcType([], [Go$String], false))], ["Type", "", (go$funcType([], [NodeType], false))], ["unexported", "text/template/parse", (go$funcType([], [], false))]]);
0Node0=0text/template/parsePos0text/template/parseNodeType0ÇNodeTypeo	NodeType = go$pkg.NodeType = go$newType(4, "Int", "parse.NodeType", "NodeType", "text/template/parse", null);
Åé		NodeType.methods = [["Type", "", [], [NodeType], false, -1]];
		(go$ptrType(NodeType)).methods = [["Type", "", [], [NodeType], false, -1]];
0
NodeType0 0ÇdPos[	Pos = go$pkg.Pos = go$newType(4, "Int", "parse.Pos", "Pos", "text/template/parse", null);
Åˆ		Pos.methods = [["Position", "", [], [Pos], false, -1], ["unexported", "text/template/parse", [], [], false, -1]];
		(go$ptrType(Pos)).methods = [["Position", "", [], [Pos], false, -1], ["unexported", "text/template/parse", [], [], false, -1]];
0Pos0 0ÇiListNodeÇZ	ListNode = go$pkg.ListNode = go$newType(0, "Struct", "parse.ListNode", "ListNode", "text/template/parse", function(NodeType_, Pos_, Nodes_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.Nodes = Nodes_ !== undefined ? Nodes_ : (go$sliceType(Node)).nil;
	});
Çï		ListNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(ListNode)).methods = [["Copy", "", [], [Node], false, -1], ["CopyList", "", [], [(go$ptrType(ListNode))], false, -1], ["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["append", "text/template/parse", [Node], [], false, -1], ["unexported", "text/template/parse", [], [], false, 1]];
		ListNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["Nodes", "Nodes", "", (go$sliceType(Node)), ""]]);
0
ListNode0Z0text/template/parseNode0text/template/parsePos0text/template/parseNodeType0ÇˆTextNodeÇZ	TextNode = go$pkg.TextNode = go$newType(0, "Struct", "parse.TextNode", "TextNode", "text/template/parse", function(NodeType_, Pos_, Text_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.Text = Text_ !== undefined ? Text_ : (go$sliceType(Go$Uint8)).nil;
	});
Ç"		TextNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(TextNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		TextNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["Text", "Text", "", (go$sliceType(Go$Uint8)), ""]]);
0
TextNode0Z0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0ÇÌPipeNodeÇ	PipeNode = go$pkg.PipeNode = go$newType(0, "Struct", "parse.PipeNode", "PipeNode", "text/template/parse", function(NodeType_, Pos_, Line_, Decl_, Cmds_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.Line = Line_ !== undefined ? Line_ : 0;
		this.Decl = Decl_ !== undefined ? Decl_ : (go$sliceType((go$ptrType(VariableNode)))).nil;
		this.Cmds = Cmds_ !== undefined ? Cmds_ : (go$sliceType((go$ptrType(CommandNode)))).nil;
	});
Ç%		PipeNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(PipeNode)).methods = [["Copy", "", [], [Node], false, -1], ["CopyPipe", "", [], [(go$ptrType(PipeNode))], false, -1], ["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["append", "text/template/parse", [(go$ptrType(CommandNode))], [], false, -1], ["unexported", "text/template/parse", [], [], false, 1]];
		PipeNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["Line", "Line", "", Go$Int, ""], ["Decl", "Decl", "", (go$sliceType((go$ptrType(VariableNode)))), ""], ["Cmds", "Cmds", "", (go$sliceType((go$ptrType(CommandNode)))), ""]]);
0
PipeNode0Å£0#text/template/parseVariableNode0"text/template/parseCommandNode0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0Ç}
ActionNodeÇñ	ActionNode = go$pkg.ActionNode = go$newType(0, "Struct", "parse.ActionNode", "ActionNode", "text/template/parse", function(NodeType_, Pos_, Line_, Pipe_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.Line = Line_ !== undefined ? Line_ : 0;
		this.Pipe = Pipe_ !== undefined ? Pipe_ : (go$ptrType(PipeNode)).nil;
	});
ÇH		ActionNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(ActionNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		ActionNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["Line", "Line", "", Go$Int, ""], ["Pipe", "Pipe", "", (go$ptrType(PipeNode)), ""]]);
0
ActionNode0{0text/template/parsePipeNode0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0ÇCCommandNodeÇb	CommandNode = go$pkg.CommandNode = go$newType(0, "Struct", "parse.CommandNode", "CommandNode", "text/template/parse", function(NodeType_, Pos_, Args_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.Args = Args_ !== undefined ? Args_ : (go$sliceType(Node)).nil;
	});
Ça		CommandNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(CommandNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["append", "text/template/parse", [Node], [], false, -1], ["unexported", "text/template/parse", [], [], false, 1]];
		CommandNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["Args", "Args", "", (go$sliceType(Node)), ""]]);
0CommandNode0Z0text/template/parseNode0text/template/parsePos0text/template/parseNodeType0ÇKIdentifierNodeÇ\	IdentifierNode = go$pkg.IdentifierNode = go$newType(0, "Struct", "parse.IdentifierNode", "IdentifierNode", "text/template/parse", function(NodeType_, Pos_, Ident_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.Ident = Ident_ !== undefined ? Ident_ : "";
	});
Çi		IdentifierNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(IdentifierNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 1], ["SetPos", "", [Pos], [(go$ptrType(IdentifierNode))], false, -1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		IdentifierNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["Ident", "Ident", "", Go$String, ""]]);
0IdentifierNode0Z0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0Ç"VariableNodeÇo	VariableNode = go$pkg.VariableNode = go$newType(0, "Struct", "parse.VariableNode", "VariableNode", "text/template/parse", function(NodeType_, Pos_, Ident_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.Ident = Ident_ !== undefined ? Ident_ : (go$sliceType(Go$String)).nil;
	});
Ç1		VariableNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(VariableNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		VariableNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["Ident", "Ident", "", (go$sliceType(Go$String)), ""]]);
0VariableNode0Z0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0Ç÷DotNodeÅø	DotNode = go$pkg.DotNode = go$newType(0, "Struct", "parse.DotNode", "DotNode", "text/template/parse", function(Pos_) {
		this.go$val = this;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
	});
Ç†		DotNode.methods = [["Position", "", [], [Pos], false, 0], ["unexported", "text/template/parse", [], [], false, 0]];
		(go$ptrType(DotNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 0], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, -1], ["unexported", "text/template/parse", [], [], false, 0]];
		DotNode.init([["Pos", "", "", Pos, ""]]);
0	DotNode0Z0text/template/parsePos0text/template/parseNode0text/template/parseNodeType0Ç÷NilNodeÅø	NilNode = go$pkg.NilNode = go$newType(0, "Struct", "parse.NilNode", "NilNode", "text/template/parse", function(Pos_) {
		this.go$val = this;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
	});
Ç†		NilNode.methods = [["Position", "", [], [Pos], false, 0], ["unexported", "text/template/parse", [], [], false, 0]];
		(go$ptrType(NilNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 0], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, -1], ["unexported", "text/template/parse", [], [], false, 0]];
		NilNode.init([["Pos", "", "", Pos, ""]]);
0	NilNode0Z0text/template/parsePos0text/template/parseNode0text/template/parseNodeType0Ç	FieldNodeÇc	FieldNode = go$pkg.FieldNode = go$newType(0, "Struct", "parse.FieldNode", "FieldNode", "text/template/parse", function(NodeType_, Pos_, Ident_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.Ident = Ident_ !== undefined ? Ident_ : (go$sliceType(Go$String)).nil;
	});
Ç(		FieldNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(FieldNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		FieldNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["Ident", "Ident", "", (go$sliceType(Go$String)), ""]]);
0	FieldNode0Z0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0Çâ	ChainNodeÇú	ChainNode = go$pkg.ChainNode = go$newType(0, "Struct", "parse.ChainNode", "ChainNode", "text/template/parse", function(NodeType_, Pos_, Node_, Field_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.Node = Node_ !== undefined ? Node_ : null;
		this.Field = Field_ !== undefined ? Field_ : (go$sliceType(Go$String)).nil;
	});
Çq		ChainNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(ChainNode)).methods = [["Add", "", [Go$String], [], false, -1], ["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		ChainNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["Node", "Node", "", Node, ""], ["Field", "Field", "", (go$sliceType(Go$String)), ""]]);
0	ChainNode0Z0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0ÇŒBoolNodeÇC	BoolNode = go$pkg.BoolNode = go$newType(0, "Struct", "parse.BoolNode", "BoolNode", "text/template/parse", function(NodeType_, Pos_, True_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.True = True_ !== undefined ? True_ : false;
	});
Ç		BoolNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(BoolNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		BoolNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["True", "True", "", Go$Bool, ""]]);
0
BoolNode0Z0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0Ç≈
NumberNodeÇù	NumberNode = go$pkg.NumberNode = go$newType(0, "Struct", "parse.NumberNode", "NumberNode", "text/template/parse", function(NodeType_, Pos_, IsInt_, IsUint_, IsFloat_, IsComplex_, Int64_, Uint64_, Float64_, Complex128_, Text_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.IsInt = IsInt_ !== undefined ? IsInt_ : false;
		this.IsUint = IsUint_ !== undefined ? IsUint_ : false;
		this.IsFloat = IsFloat_ !== undefined ? IsFloat_ : false;
		this.IsComplex = IsComplex_ !== undefined ? IsComplex_ : false;
		this.Int64 = Int64_ !== undefined ? Int64_ : new Go$Int64(0, 0);
		this.Uint64 = Uint64_ !== undefined ? Uint64_ : new Go$Uint64(0, 0);
		this.Float64 = Float64_ !== undefined ? Float64_ : 0;
		this.Complex128 = Complex128_ !== undefined ? Complex128_ : new Go$Complex128(0, 0);
		this.Text = Text_ !== undefined ? Text_ : "";
	});
Ç™		NumberNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(NumberNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["simplifyComplex", "text/template/parse", [], [], false, -1], ["unexported", "text/template/parse", [], [], false, 1]];
		NumberNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["IsInt", "IsInt", "", Go$Bool, ""], ["IsUint", "IsUint", "", Go$Bool, ""], ["IsFloat", "IsFloat", "", Go$Bool, ""], ["IsComplex", "IsComplex", "", Go$Bool, ""], ["Int64", "Int64", "", Go$Int64, ""], ["Uint64", "Uint64", "", Go$Uint64, ""], ["Float64", "Float64", "", Go$Float64, ""], ["Complex128", "Complex128", "", Go$Complex128, ""], ["Text", "Text", "", Go$String, ""]]);
0
NumberNode0Z0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0ÇG
StringNodeÇá	StringNode = go$pkg.StringNode = go$newType(0, "Struct", "parse.StringNode", "StringNode", "text/template/parse", function(NodeType_, Pos_, Quoted_, Text_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.Quoted = Quoted_ !== undefined ? Quoted_ : "";
		this.Text = Text_ !== undefined ? Text_ : "";
	});
ÇB		StringNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(StringNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		StringNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["Quoted", "Quoted", "", Go$String, ""], ["Text", "Text", "", Go$String, ""]]);
0
StringNode0Z0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0Ç÷endNodeÅø	endNode = go$pkg.endNode = go$newType(0, "Struct", "parse.endNode", "endNode", "text/template/parse", function(Pos_) {
		this.go$val = this;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
	});
Ç†		endNode.methods = [["Position", "", [], [Pos], false, 0], ["unexported", "text/template/parse", [], [], false, 0]];
		(go$ptrType(endNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 0], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, -1], ["unexported", "text/template/parse", [], [], false, 0]];
		endNode.init([["Pos", "", "", Pos, ""]]);
0	endNode0Z0text/template/parsePos0text/template/parseNode0text/template/parseNodeType0Ç¢elseNodeÇ?	elseNode = go$pkg.elseNode = go$newType(0, "Struct", "parse.elseNode", "elseNode", "text/template/parse", function(NodeType_, Pos_, Line_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.Line = Line_ !== undefined ? Line_ : 0;
	});
ÇÈ		elseNode.methods = [["Position", "", [], [Pos], false, 1], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(elseNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, -1], ["unexported", "text/template/parse", [], [], false, 1]];
		elseNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["Line", "Line", "", Go$Int, ""]]);
0
elseNode0Z0text/template/parsePos0text/template/parseNode0text/template/parseNodeType0Çv
BranchNodeÇD	BranchNode = go$pkg.BranchNode = go$newType(0, "Struct", "parse.BranchNode", "BranchNode", "text/template/parse", function(NodeType_, Pos_, Line_, Pipe_, List_, ElseList_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.Line = Line_ !== undefined ? Line_ : 0;
		this.Pipe = Pipe_ !== undefined ? Pipe_ : (go$ptrType(PipeNode)).nil;
		this.List = List_ !== undefined ? List_ : (go$ptrType(ListNode)).nil;
		this.ElseList = ElseList_ !== undefined ? ElseList_ : (go$ptrType(ListNode)).nil;
	});
Çè		BranchNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(BranchNode)).methods = [["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		BranchNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["Line", "Line", "", Go$Int, ""], ["Pipe", "Pipe", "", (go$ptrType(PipeNode)), ""], ["List", "List", "", (go$ptrType(ListNode)), ""], ["ElseList", "ElseList", "", (go$ptrType(ListNode)), ""]]);
0
BranchNode00text/template/parsePipeNode0text/template/parseListNode0text/template/parsePos0text/template/parseNodeType0ÇSIfNodeÅÍ	IfNode = go$pkg.IfNode = go$newType(0, "Struct", "parse.IfNode", "IfNode", "text/template/parse", function(BranchNode_) {
		this.go$val = this;
		this.BranchNode = BranchNode_ !== undefined ? BranchNode_ : new BranchNode.Ptr();
	});
Ç—		IfNode.methods = [["Position", "", [], [Pos], false, 0], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 0]];
		(go$ptrType(IfNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 0], ["String", "", [], [Go$String], false, 0], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 0]];
		IfNode.init([["BranchNode", "", "", BranchNode, ""]]);
0IfNode0}0!text/template/parse
BranchNode0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0Çn	RangeNodeÅˆ	RangeNode = go$pkg.RangeNode = go$newType(0, "Struct", "parse.RangeNode", "RangeNode", "text/template/parse", function(BranchNode_) {
		this.go$val = this;
		this.BranchNode = BranchNode_ !== undefined ? BranchNode_ : new BranchNode.Ptr();
	});
Ç⁄		RangeNode.methods = [["Position", "", [], [Pos], false, 0], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 0]];
		(go$ptrType(RangeNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 0], ["String", "", [], [Go$String], false, 0], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 0]];
		RangeNode.init([["BranchNode", "", "", BranchNode, ""]]);
0	RangeNode0}0!text/template/parse
BranchNode0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0ÇeWithNodeÅÚ	WithNode = go$pkg.WithNode = go$newType(0, "Struct", "parse.WithNode", "WithNode", "text/template/parse", function(BranchNode_) {
		this.go$val = this;
		this.BranchNode = BranchNode_ !== undefined ? BranchNode_ : new BranchNode.Ptr();
	});
Ç◊		WithNode.methods = [["Position", "", [], [Pos], false, 0], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 0]];
		(go$ptrType(WithNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 0], ["String", "", [], [Go$String], false, 0], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 0]];
		WithNode.init([["BranchNode", "", "", BranchNode, ""]]);
0
WithNode0}0!text/template/parse
BranchNode0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0ÇÎTemplateNodeÇ’	TemplateNode = go$pkg.TemplateNode = go$newType(0, "Struct", "parse.TemplateNode", "TemplateNode", "text/template/parse", function(NodeType_, Pos_, Line_, Name_, Pipe_) {
		this.go$val = this;
		this.NodeType = NodeType_ !== undefined ? NodeType_ : 0;
		this.Pos = Pos_ !== undefined ? Pos_ : 0;
		this.Line = Line_ !== undefined ? Line_ : 0;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.Pipe = Pipe_ !== undefined ? Pipe_ : (go$ptrType(PipeNode)).nil;
	});
Çs		TemplateNode.methods = [["Position", "", [], [Pos], false, 1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		(go$ptrType(TemplateNode)).methods = [["Copy", "", [], [Node], false, -1], ["Position", "", [], [Pos], false, 1], ["String", "", [], [Go$String], false, -1], ["Type", "", [], [NodeType], false, 0], ["unexported", "text/template/parse", [], [], false, 1]];
		TemplateNode.init([["NodeType", "", "", NodeType, ""], ["Pos", "", "", Pos, ""], ["Line", "Line", "", Go$Int, ""], ["Name", "Name", "", Go$String, ""], ["Pipe", "Pipe", "", (go$ptrType(PipeNode)), ""]]);
0TemplateNode0{0text/template/parsePipeNode0text/template/parsePos0text/template/parseNodeType0text/template/parseNode0ÇZTreeÇc	Tree = go$pkg.Tree = go$newType(0, "Struct", "parse.Tree", "Tree", "text/template/parse", function(Name_, ParseName_, Root_, text_, funcs_, lex_, token_, peekCount_, vars_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.ParseName = ParseName_ !== undefined ? ParseName_ : "";
		this.Root = Root_ !== undefined ? Root_ : (go$ptrType(ListNode)).nil;
		this.text = text_ !== undefined ? text_ : "";
		this.funcs = funcs_ !== undefined ? funcs_ : (go$sliceType((go$mapType(Go$String, go$emptyInterface)))).nil;
		this.lex = lex_ !== undefined ? lex_ : (go$ptrType(lexer)).nil;
		this.token = token_ !== undefined ? token_ : go$makeNativeArray("Struct", 3, function() { return new item.Ptr(); });
		this.peekCount = peekCount_ !== undefined ? peekCount_ : 0;
		this.vars = vars_ !== undefined ? vars_ : (go$sliceType(Go$String)).nil;
	});
Ç„		(go$ptrType(Tree)).methods = [["Copy", "", [], [(go$ptrType(Tree))], false, -1], ["ErrorContext", "", [Node], [Go$String, Go$String], false, -1], ["Parse", "", [Go$String, Go$String, Go$String, (go$mapType(Go$String, (go$ptrType(Tree)))), (go$sliceType((go$mapType(Go$String, go$emptyInterface))))], [(go$ptrType(Tree)), go$error], true, -1], ["action", "text/template/parse", [], [Node], false, -1], ["add", "text/template/parse", [(go$mapType(Go$String, (go$ptrType(Tree))))], [], false, -1], ["backup", "text/template/parse", [], [], false, -1], ["backup2", "text/template/parse", [item], [], false, -1], ["backup3", "text/template/parse", [item, item], [], false, -1], ["command", "text/template/parse", [], [(go$ptrType(CommandNode))], false, -1], ["elseControl", "text/template/parse", [], [Node], false, -1], ["endControl", "text/template/parse", [], [Node], false, -1], ["error", "text/template/parse", [go$error], [], false, -1], ["errorf", "text/template/parse", [Go$String, (go$sliceType(go$emptyInterface))], [], true, -1], ["expect", "text/template/parse", [itemType, Go$String], [item], false, -1], ["expectOneOf", "text/template/parse", [itemType, itemType, Go$String], [item], false, -1], ["hasFunction", "text/template/parse", [Go$String], [Go$Bool], false, -1], ["ifControl", "text/template/parse", [], [Node], false, -1], ["itemList", "text/template/parse", [], [(go$ptrType(ListNode)), Node], false, -1], ["next", "text/template/parse", [], [item], false, -1], ["nextNonSpace", "text/template/parse", [], [item], false, -1], ["operand", "text/template/parse", [], [Node], false, -1], ["parse", "text/template/parse", [(go$mapType(Go$String, (go$ptrType(Tree))))], [Node], false, -1], ["parseControl", "text/template/parse", [Go$Bool, Go$String], [Pos, Go$Int, (go$ptrType(PipeNode)), (go$ptrType(ListNode)), (go$ptrType(ListNode))], false, -1], ["parseDefinition", "text/template/parse", [(go$mapType(Go$String, (go$ptrType(Tree))))], [], false, -1], ["peek", "text/template/parse", [], [item], false, -1], ["peekNonSpace", "text/template/parse", [], [item], false, -1], ["pipeline", "text/template/parse", [Go$String], [(go$ptrType(PipeNode))], false, -1], ["popVars", "text/template/parse", [Go$Int], [], false, -1], ["rangeControl", "text/template/parse", [], [Node], false, -1], ["recover", "text/template/parse", [(go$ptrType(go$error))], [], false, -1], ["startParse", "text/template/parse", [(go$sliceType((go$mapType(Go$String, go$emptyInterface)))), (go$ptrType(lexer))], [], false, -1], ["stopParse", "text/template/parse", [], [], false, -1], ["templateControl", "text/template/parse", [], [Node], false, -1], ["term", "text/template/parse", [], [Node], false, -1], ["textOrAction", "text/template/parse", [], [Node], false, -1], ["unexpected", "text/template/parse", [item, Go$String], [], false, -1], ["useVar", "text/template/parse", [Pos, Go$String], [Node], false, -1], ["withControl", "text/template/parse", [], [Node], false, -1]];
		Tree.init([["Name", "Name", "", Go$String, ""], ["ParseName", "ParseName", "", Go$String, ""], ["Root", "Root", "", (go$ptrType(ListNode)), ""], ["text", "text", "text/template/parse", Go$String, ""], ["funcs", "funcs", "text/template/parse", (go$sliceType((go$mapType(Go$String, go$emptyInterface)))), ""], ["lex", "lex", "text/template/parse", (go$ptrType(lexer)), ""], ["token", "token", "text/template/parse", (go$arrayType(item, 3)), ""], ["peekCount", "peekCount", "text/template/parse", Go$Int, ""], ["vars", "vars", "text/template/parse", (go$sliceType(Go$String)), ""]]);
0Tree0Å˚0text/template/parselexer0text/template/parseNode0"text/template/parseCommandNode0text/template/parseitemType0text/template/parsePipeNode0text/template/parseListNode0text/template/parseitem0text/template/parsePos0Ç¡ ÇÇ	item.Ptr.prototype.String = function() {
		var _struct, i;
		i = (_struct = this, new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		if (i.typ === 6) {
			return "EOF";
		} else if (i.typ === 0) {
			return i.val;
		} else if (i.typ > 20) {
			return fmt.Sprintf("<%s>", new (go$sliceType(go$emptyInterface))([new Go$String(i.val)]));
		} else if (i.val.length > 10) {
			return fmt.Sprintf("%.10q...", new (go$sliceType(go$emptyInterface))([new Go$String(i.val)]));
		}
		return fmt.Sprintf("%q", new (go$sliceType(go$emptyInterface))([new Go$String(i.val)]));
	};
	item.prototype.String = function() { return this.go$val.String(); };
 0item0-0text/template/parseitem0fmtSprintf0Çÿ Ç}	lexer.Ptr.prototype.next = function() {
		var l, _tuple, r, w;
		l = this;
		if ((l.pos >> 0) >= l.input.length) {
			l.width = 0;
			return -1;
		}
		_tuple = utf8.DecodeRuneInString(l.input.substring(l.pos)), r = _tuple[0], w = _tuple[1];
		l.width = (w >> 0);
		l.pos = l.pos + (l.width) >> 0;
		return r;
	};
	lexer.prototype.next = function() { return this.go$val.next(); };
 0lexernext0B0text/template/parselexer0"unicode/utf8DecodeRuneInString0Ç$ Å≤	lexer.Ptr.prototype.peek = function() {
		var l, r;
		l = this;
		r = l.next();
		l.backup();
		return r;
	};
	lexer.prototype.peek = function() { return this.go$val.peek(); };
 0lexerpeek0Z0text/template/parselexer0text/template/parsenext0text/template/parsebackup0ÅÂ Å≠	lexer.Ptr.prototype.backup = function() {
		var l;
		l = this;
		l.pos = l.pos - (l.width) >> 0;
	};
	lexer.prototype.backup = function() { return this.go$val.backup(); };
 0lexerbackup00text/template/parselexer0Çf Ç	lexer.Ptr.prototype.emit = function(t) {
		var l, x;
		l = this;
		l.items.PushBack((x = new item.Ptr(t, l.start, l.input.substring(l.start, l.pos)), new x.constructor.Struct(x)));
		l.start = l.pos;
	};
	lexer.prototype.emit = function(t) { return this.go$val.emit(t); };
 0lexeremit0;0text/template/parselexer0text/template/parseitem0Å÷ Åû	lexer.Ptr.prototype.ignore = function() {
		var l;
		l = this;
		l.start = l.pos;
	};
	lexer.prototype.ignore = function() { return this.go$val.ignore(); };
 0lexerignore00text/template/parselexer0Çá Å˝	lexer.Ptr.prototype.accept = function(valid) {
		var l;
		l = this;
		if (strings.IndexRune(valid, l.next()) >= 0) {
			return true;
		}
		l.backup();
		return false;
	};
	lexer.prototype.accept = function(valid) { return this.go$val.accept(valid); };
 0lexeraccept0p0text/template/parselexer0strings	IndexRune0text/template/parsenext0text/template/parsebackup0Çv ÅÈ	lexer.Ptr.prototype.acceptRun = function(valid) {
		var l;
		l = this;
		while (strings.IndexRune(valid, l.next()) >= 0) {
		}
		l.backup();
	};
	lexer.prototype.acceptRun = function(valid) { return this.go$val.acceptRun(valid); };
 0lexer	acceptRun0p0text/template/parselexer0strings	IndexRune0text/template/parsenext0text/template/parsebackup0Ç- Åﬂ	lexer.Ptr.prototype.lineNumber = function() {
		var l;
		l = this;
		return 1 + strings.Count(l.input.substring(0, l.lastPos), "\n") >> 0;
	};
	lexer.prototype.lineNumber = function() { return this.go$val.lineNumber(); };
 0lexer
lineNumber000text/template/parselexer0stringsCount0Ç¶ Ç@	lexer.Ptr.prototype.errorf = function(format, args) {
		var l, x;
		l = this;
		l.items.PushBack((x = new item.Ptr(0, l.start, fmt.Sprintf(format, args)), new x.constructor.Struct(x)));
		return go$throwNilPointerError;
	};
	lexer.prototype.errorf = function(format, args) { return this.go$val.errorf(format, args); };
 0lexererrorf0K0text/template/parselexer0fmtSprintf0text/template/parseitem0Ç  Çç	lexer.Ptr.prototype.nextItem = function() {
		var l, element, x, _struct, item$1, _struct$1;
		l = this;
		element = l.items.Front();
		while (element === (go$ptrType(list.Element)).nil) {
			l.state = l.state(l);
			element = l.items.Front();
		}
		l.items.Remove(element);
		item$1 = (_struct = (x = element.Value, (x !== null && x.constructor === item ? x.go$val : go$typeAssertionFailed(x, item))), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		l.lastPos = item$1.pos;
		return (_struct$1 = item$1, new item.Ptr(_struct$1.typ, _struct$1.pos, _struct$1.val));
	};
	lexer.prototype.nextItem = function() { return this.go$val.nextItem(); };
 0lexernextItem0V0text/template/parselexer0container/listElement0text/template/parseitem0ÇílexÇ	lex = function(name, input, left, right) {
		var l;
		if (left === "") {
			left = "{{";
		}
		if (right === "") {
			right = "}}";
		}
		l = new lexer.Ptr(name, input, left, right, go$throwNilPointerError, 0, 0, 0, 0, list.New(), 0);
		l.state = lexText;
		return l;
	};
 0lex0m0container/listList0container/listNew0text/template/parselexer0text/template/parselexText0Ç€lexTextÇJ	lexText = function(l) {
		while (true) {
			if (strings.HasPrefix(l.input.substring(l.pos), l.leftDelim)) {
				if (l.pos > l.start) {
					l.emit(18);
				}
				return lexLeftDelim;
			}
			if (l.next() === -1) {
				break;
			}
		}
		if (l.pos > l.start) {
			l.emit(18);
		}
		l.emit(6);
		return go$throwNilPointerError;
	};
 0	lexText0u0strings	HasPrefix0text/template/parseemit0#text/template/parselexLeftDelim0text/template/parsenext0ÇâlexLeftDelimÅÊ	lexLeftDelim = function(l) {
		l.pos = l.pos + ((l.leftDelim.length >> 0)) >> 0;
		if (strings.HasPrefix(l.input.substring(l.pos), "/*")) {
			return lexComment;
		}
		l.emit(9);
		l.parenDepth = 0;
		return lexInsideAction;
	};
 0lexLeftDelim0~0strings	HasPrefix0!text/template/parse
lexComment0text/template/parseemit0&text/template/parselexInsideAction0Ç∫
lexCommentÇ	lexComment = function(l) {
		var i;
		l.pos = l.pos + 2 >> 0;
		i = strings.Index(l.input.substring(l.pos), "*/");
		if (i < 0) {
			return l.errorf("unclosed comment", new (go$sliceType(go$emptyInterface))([]));
		}
		l.pos = l.pos + (((i + 2 >> 0) >> 0)) >> 0;
		if (!strings.HasPrefix(l.input.substring(l.pos), l.rightDelim)) {
			return l.errorf("comment ends before closing delimiter", new (go$sliceType(go$emptyInterface))([]));
		}
		l.pos = l.pos + ((l.rightDelim.length >> 0)) >> 0;
		l.ignore();
		return lexText;
	};
 0
lexComment0ÅÜ0stringsIndex0text/template/parseerrorf0strings	HasPrefix0text/template/parseignore0text/template/parselexText0Å€lexRightDelimx	lexRightDelim = function(l) {
		l.pos = l.pos + ((l.rightDelim.length >> 0)) >> 0;
		l.emit(14);
		return lexText;
	};
 0lexRightDelim0=0text/template/parseemit0text/template/parselexText0Ç	älexInsideActionÇ	lexInsideAction = function(l) {
		var r, r$1;
		if (strings.HasPrefix(l.input.substring(l.pos), l.rightDelim)) {
			if (l.parenDepth === 0) {
				return lexRightDelim;
			}
			return l.errorf("unclosed left paren", new (go$sliceType(go$emptyInterface))([]));
		}
		r = l.next();
		if ((r === -1) || isEndOfLine(r)) {
			return l.errorf("unclosed action", new (go$sliceType(go$emptyInterface))([]));
		} else if (isSpace(r)) {
			return lexSpace;
		} else if (r === 58) {
			if (!((l.next() === 61))) {
				return l.errorf("expected :=", new (go$sliceType(go$emptyInterface))([]));
			}
			l.emit(5);
		} else if (r === 124) {
			l.emit(12);
		} else if (r === 34) {
			return lexQuote;
		} else if (r === 96) {
			return lexRawQuote;
		} else if (r === 36) {
			return lexVariable;
		} else if (r === 39) {
			return lexChar;
		} else if (r === 46) {
			if (l.pos < (l.input.length >> 0)) {
				r$1 = l.input.charCodeAt(l.pos);
				if (r$1 < 48 || 57 < r$1) {
					return lexField;
				}
			}
			l.backup();
			return lexNumber;
		} else if ((r === 43) || (r === 45) || (48 <= r && r <= 57)) {
			l.backup();
			return lexNumber;
		} else if (isAlphaNumeric(r)) {
			l.backup();
			return lexIdentifier;
		} else if (r === 40) {
			l.emit(10);
			l.parenDepth = l.parenDepth + 1 >> 0;
			return lexInsideAction;
		} else if (r === 41) {
			l.emit(15);
			l.parenDepth = l.parenDepth - 1 >> 0;
			if (l.parenDepth < 0) {
				return l.errorf("unexpected right paren %#U", new (go$sliceType(go$emptyInterface))([new Go$Int32(r)]));
			}
			return lexInsideAction;
		} else if (r <= 127 && unicode.IsPrint(r)) {
			l.emit(2);
			return lexInsideAction;
		} else {
			return l.errorf("unrecognized character in action: %#U", new (go$sliceType(go$emptyInterface))([new Go$Int32(r)]));
		}
		return lexInsideAction;
	};
 0lexInsideAction0ÇF0%text/template/parseisAlphaNumeric0text/template/parselexSpace0text/template/parselexQuote0"text/template/parselexRawQuote0"text/template/parselexVariable0text/template/parselexChar0text/template/parselexField0text/template/parsebackup0 text/template/parse	lexNumber0"text/template/parseisEndOfLine0text/template/parseisSpace0text/template/parsenext0strings	HasPrefix0$text/template/parselexRightDelim0text/template/parseerrorf0unicodeIsPrint0text/template/parseemit0$text/template/parselexIdentifier0Ç1lexSpaceu	lexSpace = function(l) {
		while (isSpace(l.peek())) {
			l.next();
		}
		l.emit(16);
		return lexInsideAction;
	};
 0
lexSpace0Åü0text/template/parseisSpace0text/template/parsepeek0text/template/parsenext0text/template/parseemit0&text/template/parselexInsideAction0Ç˛lexIdentifierÇÃ	lexIdentifier = function(l) {
		var r, word, _entry, _entry$1;
		Loop:
		while (true) {
			r = l.next();
			if (isAlphaNumeric(r)) {
			} else {
				l.backup();
				word = l.input.substring(l.start, l.pos);
				if (!l.atTerminator()) {
					return l.errorf("bad character %#U", new (go$sliceType(go$emptyInterface))([new Go$Int32(r)]));
				}
				if ((_entry = key[word], _entry !== undefined ? _entry.v : 0) > 20) {
					l.emit((_entry$1 = key[word], _entry$1 !== undefined ? _entry$1.v : 0));
				} else if (word.charCodeAt(0) === 46) {
					l.emit(7);
				} else if (word === "true" || word === "false") {
					l.emit(1);
				} else {
					l.emit(8);
				}
				break Loop;
			}
		}
		return lexInsideAction;
	};
 0lexIdentifier0Ç0text/template/parsebackup0text/template/parseerrorf0text/template/parseemit0&text/template/parselexInsideAction0text/template/parsenext0%text/template/parseisAlphaNumeric0#text/template/parseatTerminator0text/template/parsekey0ÅàlexFieldA	lexField = function(l) {
		return lexFieldOrVariable(l, 7);
	};
 0
lexField0+0)text/template/parselexFieldOrVariable0ÇFlexVariableÅç	lexVariable = function(l) {
		if (l.atTerminator()) {
			l.emit(19);
			return lexInsideAction;
		}
		return lexFieldOrVariable(l, 19);
	};
 0lexVariable0Åï0#text/template/parseatTerminator0text/template/parseemit0&text/template/parselexInsideAction0)text/template/parselexFieldOrVariable0ÇÎlexFieldOrVariableÇÃ	lexFieldOrVariable = function(l, typ) {
		var r;
		if (l.atTerminator()) {
			if (typ === 19) {
				l.emit(19);
			} else {
				l.emit(21);
			}
			return lexInsideAction;
		}
		r = 0;
		while (true) {
			r = l.next();
			if (!isAlphaNumeric(r)) {
				l.backup();
				break;
			}
		}
		if (!l.atTerminator()) {
			return l.errorf("bad character %#U", new (go$sliceType(go$emptyInterface))([new Go$Int32(r)]));
		}
		l.emit(typ);
		return lexInsideAction;
	};
 0lexFieldOrVariable0ÅÏ0#text/template/parseatTerminator0text/template/parseemit0&text/template/parselexInsideAction0text/template/parsenext0%text/template/parseisAlphaNumeric0text/template/parsebackup0text/template/parseerrorf0Ç« Ç	lexer.Ptr.prototype.atTerminator = function() {
		var l, r, _ref, rd, _tuple;
		l = this;
		r = l.peek();
		if (isSpace(r) || isEndOfLine(r)) {
			return true;
		}
		_ref = r;
		if (_ref === -1 || _ref === 46 || _ref === 44 || _ref === 124 || _ref === 58 || _ref === 41 || _ref === 40) {
			return true;
		}
		if (_tuple = utf8.DecodeRuneInString(l.rightDelim), rd = _tuple[0], rd === r) {
			return true;
		}
		return false;
	};
	lexer.prototype.atTerminator = function() { return this.go$val.atTerminator(); };
 0lexeratTerminator0Å£0text/template/parselexer0text/template/parsepeek0text/template/parseisSpace0"text/template/parseisEndOfLine0"unicode/utf8DecodeRuneInString0ÇælexCharÇ 	lexChar = function(l) {
		var _ref, r;
		Loop:
		while (true) {
			_ref = l.next();
			switch (0) { default: if (_ref === 92) {
				if (r = l.next(), !((r === -1)) && !((r === 10))) {
					break;
				}
				return l.errorf("unterminated character constant", new (go$sliceType(go$emptyInterface))([]));
			} else if (_ref === -1 || _ref === 10) {
				return l.errorf("unterminated character constant", new (go$sliceType(go$emptyInterface))([]));
			} else if (_ref === 39) {
				break Loop;
			} }
		}
		l.emit(3);
		return lexInsideAction;
	};
 0	lexChar0ÅÅ0text/template/parsenext0text/template/parseerrorf0text/template/parseemit0&text/template/parselexInsideAction0ÇÒ	lexNumberÇ,	lexNumber = function(l) {
		var sign;
		if (!l.scanNumber()) {
			return l.errorf("bad number syntax: %q", new (go$sliceType(go$emptyInterface))([new Go$String(l.input.substring(l.start, l.pos))]));
		}
		if (sign = l.peek(), (sign === 43) || (sign === 45)) {
			if (!l.scanNumber() || !((l.input.charCodeAt((l.pos - 1 >> 0)) === 105))) {
				return l.errorf("bad number syntax: %q", new (go$sliceType(go$emptyInterface))([new Go$String(l.input.substring(l.start, l.pos))]));
			}
			l.emit(4);
		} else {
			l.emit(11);
		}
		return lexInsideAction;
	};
 0	lexNumber0Å§0!text/template/parse
scanNumber0text/template/parseerrorf0text/template/parsepeek0text/template/parseemit0&text/template/parselexInsideAction0Ç¯ Ç	lexer.Ptr.prototype.scanNumber = function() {
		var l, digits;
		l = this;
		l.accept("+-");
		digits = "0123456789";
		if (l.accept("0") && l.accept("xX")) {
			digits = "0123456789abcdefABCDEF";
		}
		l.acceptRun(digits);
		if (l.accept(".")) {
			l.acceptRun(digits);
		}
		if (l.accept("eE")) {
			l.accept("+-");
			l.acceptRun("0123456789");
		}
		l.accept("i");
		if (isAlphaNumeric(l.peek())) {
			l.next();
			return false;
		}
		return true;
	};
	lexer.prototype.scanNumber = function() { return this.go$val.scanNumber(); };
 0lexer
scanNumber0Å¿0text/template/parselexer0text/template/parseaccept0 text/template/parse	acceptRun0%text/template/parseisAlphaNumeric0text/template/parsepeek0text/template/parsenext0Ç∏lexQuoteÇ	lexQuote = function(l) {
		var _ref, r;
		Loop:
		while (true) {
			_ref = l.next();
			switch (0) { default: if (_ref === 92) {
				if (r = l.next(), !((r === -1)) && !((r === 10))) {
					break;
				}
				return l.errorf("unterminated quoted string", new (go$sliceType(go$emptyInterface))([]));
			} else if (_ref === -1 || _ref === 10) {
				return l.errorf("unterminated quoted string", new (go$sliceType(go$emptyInterface))([]));
			} else if (_ref === 34) {
				break Loop;
			} }
		}
		l.emit(17);
		return lexInsideAction;
	};
 0
lexQuote0ÅÅ0text/template/parsenext0text/template/parseerrorf0text/template/parseemit0&text/template/parselexInsideAction0ÇÂlexRawQuoteÇ?	lexRawQuote = function(l) {
		var _ref;
		Loop:
		while (true) {
			_ref = l.next();
			if (_ref === -1 || _ref === 10) {
				return l.errorf("unterminated raw quoted string", new (go$sliceType(go$emptyInterface))([]));
			} else if (_ref === 96) {
				break Loop;
			}
		}
		l.emit(13);
		return lexInsideAction;
	};
 0lexRawQuote0ÅÅ0text/template/parsenext0text/template/parseerrorf0text/template/parseemit0&text/template/parselexInsideAction0YisSpace?	isSpace = function(r) {
		return (r === 32) || (r === 9);
	};
 0	isSpace0 0fisEndOfLineD	isEndOfLine = function(r) {
		return (r === 13) || (r === 10);
	};
 0isEndOfLine0 0Å∑isAlphaNumericf	isAlphaNumeric = function(r) {
		return (r === 95) || unicode.IsLetter(r) || unicode.IsDigit(r);
	};
 0isAlphaNumeric0)0unicodeIsLetter0unicodeIsDigit0Åﬂ Å≥	Pos.prototype.Position = function() {
		var p;
		p = this.go$val;
		return p;
	};
	go$ptrType(Pos).prototype.Position = function() { return new Pos(this.go$get()).Position(); };
 0Pos00text/template/parsePos0Å… Åë	Pos.prototype.unexported = function() {
	};
	go$ptrType(Pos).prototype.unexported = function() { return new Pos(this.go$get()).unexported(); };
 0Pos
unexported00text/template/parsePos0ÅÏ Å∂	NodeType.prototype.Type = function() {
		var t;
		t = this.go$val;
		return t;
	};
	go$ptrType(NodeType).prototype.Type = function() { return new NodeType(this.go$get()).Type(); };
 0
NodeType0!0text/template/parseNodeType0ÅµnewList]	newList = function(pos) {
		return new ListNode.Ptr(11, pos, (go$sliceType(Node)).nil);
	};
 0	newList0>0text/template/parseNode0text/template/parseListNode0Åı Å∑	ListNode.Ptr.prototype.append = function(n) {
		var l;
		l = this;
		l.Nodes = go$append(l.Nodes, n);
	};
	ListNode.prototype.append = function(n) { return this.go$val.append(n); };
 0ListNodeappend0!0text/template/parseListNode0Ça Ç
	ListNode.Ptr.prototype.String = function() {
		var l, b, _ref, _i, _slice, _index, n;
		l = this;
		b = new bytes.Buffer.Ptr();
		_ref = l.Nodes;
		_i = 0;
		while (_i < _ref.length) {
			n = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			fmt.Fprint(b, new (go$sliceType(go$emptyInterface))([n]));
			_i++;
		}
		return b.String();
	};
	ListNode.prototype.String = function() { return this.go$val.String(); };
 0
ListNode0A0text/template/parseListNode0bytesBuffer0fmtFprint0Çí Ç	ListNode.Ptr.prototype.CopyList = function() {
		var l, n, _ref, _i, _slice, _index, elem;
		l = this;
		if (l === (go$ptrType(ListNode)).nil) {
			return l;
		}
		n = newList(l.Pos);
		_ref = l.Nodes;
		_i = 0;
		while (_i < _ref.length) {
			elem = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			n.append(elem.Copy());
			_i++;
		}
		return n;
	};
	ListNode.prototype.CopyList = function() { return this.go$val.CopyList(); };
 0
ListNode0`0text/template/parseListNode0text/template/parsenewList0text/template/parseappend0Åÿ Å¢	ListNode.Ptr.prototype.Copy = function() {
		var l;
		l = this;
		return l.CopyList();
	};
	ListNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0
ListNode0!0text/template/parseListNode0ÅπnewText~	newText = function(pos, text) {
		return new TextNode.Ptr(0, pos, new (go$sliceType(Go$Uint8))(go$stringToBytes(text)));
	};
 0	newText0!0text/template/parseTextNode0ÇM Å‰	TextNode.Ptr.prototype.String = function() {
		var t;
		t = this;
		return fmt.Sprintf(textFormat, new (go$sliceType(go$emptyInterface))([t.Text]));
	};
	TextNode.prototype.String = function() { return this.go$val.String(); };
 0
TextNode0T0text/template/parseTextNode0fmtSprintf0!text/template/parse
textFormat0Ç ÅÊ	TextNode.Ptr.prototype.Copy = function() {
		var t;
		t = this;
		return new TextNode.Ptr(0, 0, go$appendSlice(new (go$sliceType(Go$Uint8))([]), t.Text));
	};
	TextNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0
TextNode0!0text/template/parseTextNode0ÇnewPipelineÅé	newPipeline = function(pos, line, decl) {
		return new PipeNode.Ptr(14, pos, line, decl, (go$sliceType((go$ptrType(CommandNode)))).nil);
	};
 0newPipeline0j0#text/template/parseVariableNode0"text/template/parseCommandNode0text/template/parsePipeNode0Ç ÅÕ	PipeNode.Ptr.prototype.append = function(command) {
		var p;
		p = this;
		p.Cmds = go$append(p.Cmds, command);
	};
	PipeNode.prototype.append = function(command) { return this.go$val.append(command); };
 0PipeNodeappend0!0text/template/parsePipeNode0ÇÒ Ç∫	PipeNode.Ptr.prototype.String = function() {
		var p, s, _ref, _i, _slice, _index, v, i, _ref$1, _i$1, _slice$1, _index$1, c, i$1;
		p = this;
		s = "";
		if (p.Decl.length > 0) {
			_ref = p.Decl;
			_i = 0;
			while (_i < _ref.length) {
				v = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				i = _i;
				if (i > 0) {
					s = s + ", ";
				}
				s = s + (v.String());
				_i++;
			}
			s = s + " := ";
		}
		_ref$1 = p.Cmds;
		_i$1 = 0;
		while (_i$1 < _ref$1.length) {
			c = (_slice$1 = _ref$1, _index$1 = _i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			i$1 = _i$1;
			if (i$1 > 0) {
				s = s + " | ";
			}
			s = s + (c.String());
			_i$1++;
		}
		return s;
	};
	PipeNode.prototype.String = function() { return this.go$val.String(); };
 0
PipeNode0!0text/template/parsePipeNode0Çî Ç–	PipeNode.Ptr.prototype.CopyPipe = function() {
		var p, decl, _ref, _i, _slice, _index, d, x, n, _ref$1, _i$1, _slice$1, _index$1, c, x$1;
		p = this;
		if (p === (go$ptrType(PipeNode)).nil) {
			return p;
		}
		decl = (go$sliceType((go$ptrType(VariableNode)))).nil;
		_ref = p.Decl;
		_i = 0;
		while (_i < _ref.length) {
			d = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			decl = go$append(decl, (x = d.Copy(), (x !== null && x.constructor === (go$ptrType(VariableNode)) ? x.go$val : go$typeAssertionFailed(x, (go$ptrType(VariableNode))))));
			_i++;
		}
		n = newPipeline(p.Pos, p.Line, decl);
		_ref$1 = p.Cmds;
		_i$1 = 0;
		while (_i$1 < _ref$1.length) {
			c = (_slice$1 = _ref$1, _index$1 = _i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			n.append((x$1 = c.Copy(), (x$1 !== null && x$1.constructor === (go$ptrType(CommandNode)) ? x$1.go$val : go$typeAssertionFailed(x$1, (go$ptrType(CommandNode))))));
			_i$1++;
		}
		return n;
	};
	PipeNode.prototype.CopyPipe = function() { return this.go$val.CopyPipe(); };
 0
PipeNode0Å≠0text/template/parsePipeNode0#text/template/parseVariableNode0"text/template/parsenewPipeline0text/template/parseappend0"text/template/parseCommandNode0Åÿ Å¢	PipeNode.Ptr.prototype.Copy = function() {
		var p;
		p = this;
		return p.CopyPipe();
	};
	PipeNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0
PipeNode0!0text/template/parsePipeNode0Å¿	newAction^	newAction = function(pos, line, pipe) {
		return new ActionNode.Ptr(1, pos, line, pipe);
	};
 0	newAction0D0text/template/parsePipeNode0!text/template/parse
ActionNode0Ç0 ÅÊ	ActionNode.Ptr.prototype.String = function() {
		var a;
		a = this;
		return fmt.Sprintf("{{%s}}", new (go$sliceType(go$emptyInterface))([a.Pipe]));
	};
	ActionNode.prototype.String = function() { return this.go$val.String(); };
 0
ActionNode030!text/template/parse
ActionNode0fmtSprintf0Ç! Å≈	ActionNode.Ptr.prototype.Copy = function() {
		var a;
		a = this;
		return newAction(a.Pos, a.Line, a.Pipe.CopyPipe());
	};
	ActionNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0
ActionNode0E0!text/template/parse
ActionNode0 text/template/parse	newAction0Å√
newCommandb	newCommand = function(pos) {
		return new CommandNode.Ptr(4, pos, (go$sliceType(Node)).nil);
	};
 0
newCommand0A0text/template/parseNode0"text/template/parseCommandNode0Ç Å√	CommandNode.Ptr.prototype.append = function(arg) {
		var c;
		c = this;
		c.Args = go$append(c.Args, arg);
	};
	CommandNode.prototype.append = function(arg) { return this.go$val.append(arg); };
 0CommandNodeappend0$0"text/template/parseCommandNode0Çq Ç	CommandNode.Ptr.prototype.String = function() {
		var c, s, _ref, _i, _slice, _index, arg, i, ok, _tuple, arg$1;
		c = this;
		s = "";
		_ref = c.Args;
		_i = 0;
		while (_i < _ref.length) {
			arg = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (i > 0) {
				s = s + " ";
			}
			if (_tuple = (arg !== null && arg.constructor === (go$ptrType(PipeNode)) ? [arg.go$val, true] : [(go$ptrType(PipeNode)).nil, false]), arg$1 = _tuple[0], ok = _tuple[1], ok) {
				s = s + ("(" + arg$1.String() + ")");
				_i++;
				continue;
			}
			s = s + (arg.String());
			_i++;
		}
		return s;
	};
	CommandNode.prototype.String = function() { return this.go$val.String(); };
 0CommandNode0E0"text/template/parseCommandNode0text/template/parsePipeNode0Çó Ç	CommandNode.Ptr.prototype.Copy = function() {
		var c, n, _ref, _i, _slice, _index, c$1;
		c = this;
		if (c === (go$ptrType(CommandNode)).nil) {
			return c;
		}
		n = newCommand(c.Pos);
		_ref = c.Args;
		_i = 0;
		while (_i < _ref.length) {
			c$1 = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			n.append(c$1.Copy());
			_i++;
		}
		return n;
	};
	CommandNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0CommandNode0f0"text/template/parseCommandNode0!text/template/parse
newCommand0text/template/parseappend0ÅπNewIdentifierl	NewIdentifier = go$pkg.NewIdentifier = function(ident) {
		return new IdentifierNode.Ptr(9, 0, ident);
	};
 0NewIdentifier0'0%text/template/parseIdentifierNode0Ç Å¡	IdentifierNode.Ptr.prototype.SetPos = function(pos) {
		var i;
		i = this;
		i.Pos = pos;
		return i;
	};
	IdentifierNode.prototype.SetPos = function(pos) { return this.go$val.SetPos(pos); };
 0IdentifierNode0'0%text/template/parseIdentifierNode0ÅÒ ÅØ	IdentifierNode.Ptr.prototype.String = function() {
		var i;
		i = this;
		return i.Ident;
	};
	IdentifierNode.prototype.String = function() { return this.go$val.String(); };
 0IdentifierNode0'0%text/template/parseIdentifierNode0Ç. Å∆	IdentifierNode.Ptr.prototype.Copy = function() {
		var i;
		i = this;
		return NewIdentifier(i.Ident).SetPos(i.Pos);
	};
	IdentifierNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0IdentifierNode0M0%text/template/parseIdentifierNode0$text/template/parseNewIdentifier0Å∆newVariablem	newVariable = function(pos, ident) {
		return new VariableNode.Ptr(18, pos, strings.Split(ident, "."));
	};
 0newVariable070stringsSplit0#text/template/parseVariableNode0Ç= Ç˛	VariableNode.Ptr.prototype.String = function() {
		var v, s, _ref, _i, _slice, _index, id, i;
		v = this;
		s = "";
		_ref = v.Ident;
		_i = 0;
		while (_i < _ref.length) {
			id = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (i > 0) {
				s = s + ".";
			}
			s = s + (id);
			_i++;
		}
		return s;
	};
	VariableNode.prototype.String = function() { return this.go$val.String(); };
 0VariableNode0%0#text/template/parseVariableNode0Ç7 Å˘	VariableNode.Ptr.prototype.Copy = function() {
		var v;
		v = this;
		return new VariableNode.Ptr(18, v.Pos, go$appendSlice(new (go$sliceType(Go$String))([]), v.Ident));
	};
	VariableNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0VariableNode0%0#text/template/parseVariableNode0unewDot=	newDot = function(pos) {
		return new DotNode.Ptr(pos);
	};
 0newDot0 0text/template/parseDotNode0Å… Åï	DotNode.Ptr.prototype.Type = function() {
		var d;
		d = this;
		return 5;
	};
	DotNode.prototype.Type = function() { return this.go$val.Type(); };
 0	DotNode0 0text/template/parseDotNode0Å— Åù	DotNode.Ptr.prototype.String = function() {
		var d;
		d = this;
		return ".";
	};
	DotNode.prototype.String = function() { return this.go$val.String(); };
 0	DotNode0 0text/template/parseDotNode0ÅÙ Å°	DotNode.Ptr.prototype.Copy = function() {
		var d;
		d = this;
		return newDot(d.Pos);
	};
	DotNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0	DotNode0?0text/template/parseDotNode0text/template/parsenewDot0unewNil=	newNil = function(pos) {
		return new NilNode.Ptr(pos);
	};
 0newNil0 0text/template/parseNilNode0Å  Åñ	NilNode.Ptr.prototype.Type = function() {
		var n;
		n = this;
		return 12;
	};
	NilNode.prototype.Type = function() { return this.go$val.Type(); };
 0	NilNode0 0text/template/parseNilNode0Å” Åü	NilNode.Ptr.prototype.String = function() {
		var n;
		n = this;
		return "nil";
	};
	NilNode.prototype.String = function() { return this.go$val.String(); };
 0	NilNode0 0text/template/parseNilNode0ÅÙ Å°	NilNode.Ptr.prototype.Copy = function() {
		var n;
		n = this;
		return newNil(n.Pos);
	};
	NilNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0	NilNode0?0text/template/parseNilNode0text/template/parsenewNil0Å√newFields	newField = function(pos, ident) {
		return new FieldNode.Ptr(8, pos, strings.Split(ident.substring(1), "."));
	};
 0
newField040stringsSplit0 text/template/parse	FieldNode0Ç Ç 	FieldNode.Ptr.prototype.String = function() {
		var f, s, _ref, _i, _slice, _index, id;
		f = this;
		s = "";
		_ref = f.Ident;
		_i = 0;
		while (_i < _ref.length) {
			id = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			s = s + ("." + id);
			_i++;
		}
		return s;
	};
	FieldNode.prototype.String = function() { return this.go$val.String(); };
 0	FieldNode0"0 text/template/parse	FieldNode0Ç' ÅÔ	FieldNode.Ptr.prototype.Copy = function() {
		var f;
		f = this;
		return new FieldNode.Ptr(8, f.Pos, go$appendSlice(new (go$sliceType(Go$String))([]), f.Ident));
	};
	FieldNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0	FieldNode0"0 text/template/parse	FieldNode0Å≠newChaino	newChain = function(pos, node) {
		return new ChainNode.Ptr(3, pos, node, (go$sliceType(Go$String)).nil);
	};
 0
newChain0"0 text/template/parse	ChainNode0Ç‹ Ç£	ChainNode.Ptr.prototype.Add = function(field) {
		var c;
		c = this;
		if ((field.length === 0) || !((field.charCodeAt(0) === 46))) {
			throw go$panic(new Go$String("no dot in field"));
		}
		field = field.substring(1);
		if (field === "") {
			throw go$panic(new Go$String("empty field"));
		}
		c.Field = go$append(c.Field, field);
	};
	ChainNode.prototype.Add = function(field) { return this.go$val.Add(field); };
 0	ChainNode0"0 text/template/parse	ChainNode0Ç	 ÇØ	ChainNode.Ptr.prototype.String = function() {
		var c, s, ok, _tuple, x, _ref, _i, _slice, _index, field;
		c = this;
		s = c.Node.String();
		if (_tuple = (x = c.Node, (x !== null && x.constructor === (go$ptrType(PipeNode)) ? [x.go$val, true] : [(go$ptrType(PipeNode)).nil, false])), ok = _tuple[1], ok) {
			s = "(" + s + ")";
		}
		_ref = c.Field;
		_i = 0;
		while (_i < _ref.length) {
			field = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			s = s + ("." + field);
			_i++;
		}
		return s;
	};
	ChainNode.prototype.String = function() { return this.go$val.String(); };
 0	ChainNode0C0 text/template/parse	ChainNode0text/template/parsePipeNode0Ç/ Å˜	ChainNode.Ptr.prototype.Copy = function() {
		var c;
		c = this;
		return new ChainNode.Ptr(3, c.Pos, c.Node, go$appendSlice(new (go$sliceType(Go$String))([]), c.Field));
	};
	ChainNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0	ChainNode0"0 text/template/parse	ChainNode0ÅçnewBoolR	newBool = function(pos, true$1) {
		return new BoolNode.Ptr(2, pos, true$1);
	};
 0	newBool0!0text/template/parseBoolNode0Åˇ Å…	BoolNode.Ptr.prototype.String = function() {
		var b;
		b = this;
		if (b.True) {
			return "true";
		}
		return "false";
	};
	BoolNode.prototype.String = function() { return this.go$val.String(); };
 0
BoolNode0!0text/template/parseBoolNode0Ç Å¨	BoolNode.Ptr.prototype.Copy = function() {
		var b;
		b = this;
		return newBool(b.Pos, b.True);
	};
	BoolNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0
BoolNode0A0text/template/parseBoolNode0text/template/parsenewBool0Ç^	newNumberÇ{	newNumber = function(pos, text, typ) {
		var n, _ref, _tuple, rune, tail, err, err$1, _tuple$1, v, _tuple$2, f, err$2, _tuple$3, u, err$3, _tuple$4, i, _tuple$5, f$1, err$4;
		n = new NumberNode.Ptr(13, pos, false, false, false, false, new Go$Int64(0, 0), new Go$Uint64(0, 0), 0, new Go$Complex128(0, 0), text);
		_ref = typ;
		if (_ref === 3) {
			_tuple = strconv.UnquoteChar(text.substring(1), text.charCodeAt(0)), rune = _tuple[0], tail = _tuple[2], err = _tuple[3];
			if (!(go$interfaceIsEqual(err, null))) {
				return [(go$ptrType(NumberNode)).nil, err];
			}
			if (!(tail === "'")) {
				return [(go$ptrType(NumberNode)).nil, fmt.Errorf("malformed character constant: %s", new (go$sliceType(go$emptyInterface))([new Go$String(text)]))];
			}
			n.Int64 = new Go$Int64(0, rune);
			n.IsInt = true;
			n.Uint64 = new Go$Uint64(0, rune);
			n.IsUint = true;
			n.Float64 = rune;
			n.IsFloat = true;
			return [n, null];
		} else if (_ref === 4) {
			if (_tuple$1 = fmt.Sscan(text, new (go$sliceType(go$emptyInterface))([new (go$ptrType(Go$Complex128))(function() { return n.Complex128; }, function(v) { n.Complex128 = v; })])), err$1 = _tuple$1[1], !(go$interfaceIsEqual(err$1, null))) {
				return [(go$ptrType(NumberNode)).nil, err$1];
			}
			n.IsComplex = true;
			n.simplifyComplex();
			return [n, null];
		}
		if (text.length > 0 && (text.charCodeAt((text.length - 1 >> 0)) === 105)) {
			_tuple$2 = strconv.ParseFloat(text.substring(0, (text.length - 1 >> 0)), 64), f = _tuple$2[0], err$2 = _tuple$2[1];
			if (go$interfaceIsEqual(err$2, null)) {
				n.IsComplex = true;
				n.Complex128 = new Go$Complex128(0, f);
				n.simplifyComplex();
				return [n, null];
			}
		}
		_tuple$3 = strconv.ParseUint(text, 0, 64), u = _tuple$3[0], err$3 = _tuple$3[1];
		if (go$interfaceIsEqual(err$3, null)) {
			n.IsUint = true;
			n.Uint64 = u;
		}
		_tuple$4 = strconv.ParseInt(text, 0, 64), i = _tuple$4[0], err$3 = _tuple$4[1];
		if (go$interfaceIsEqual(err$3, null)) {
			n.IsInt = true;
			n.Int64 = i;
			if ((i.high === 0 && i.low === 0)) {
				n.IsUint = true;
				n.Uint64 = u;
			}
		}
		if (n.IsInt) {
			n.IsFloat = true;
			n.Float64 = go$flatten64(n.Int64);
		} else if (n.IsUint) {
			n.IsFloat = true;
			n.Float64 = go$flatten64(n.Uint64);
		} else {
			_tuple$5 = strconv.ParseFloat(text, 64), f$1 = _tuple$5[0], err$4 = _tuple$5[1];
			if (go$interfaceIsEqual(err$4, null)) {
				n.IsFloat = true;
				n.Float64 = f$1;
				if (!n.IsInt && (go$flatten64(new Go$Int64(0, f$1)) === f$1)) {
					n.IsInt = true;
					n.Int64 = new Go$Int64(0, f$1);
				}
				if (!n.IsUint && (go$flatten64(new Go$Uint64(0, f$1)) === f$1)) {
					n.IsUint = true;
					n.Uint64 = new Go$Uint64(0, f$1);
				}
			}
		}
		if (!n.IsInt && !n.IsUint && !n.IsFloat) {
			return [(go$ptrType(NumberNode)).nil, fmt.Errorf("illegal number syntax: %q", new (go$sliceType(go$emptyInterface))([new Go$String(text)]))];
		}
		return [n, null];
	};
 0	newNumber0Å¬0strconvUnquoteChar0fmtErrorf0fmtSscan0&text/template/parsesimplifyComplex0strconv	ParseUint0!text/template/parse
NumberNode0strconv
ParseFloat0strconvParseInt0Çm Ç!	NumberNode.Ptr.prototype.simplifyComplex = function() {
		var n;
		n = this;
		n.IsFloat = n.Complex128.imag === 0;
		if (n.IsFloat) {
			n.Float64 = n.Complex128.real;
			n.IsInt = go$flatten64(new Go$Int64(0, n.Float64)) === n.Float64;
			if (n.IsInt) {
				n.Int64 = new Go$Int64(0, n.Float64);
			}
			n.IsUint = go$flatten64(new Go$Uint64(0, n.Float64)) === n.Float64;
			if (n.IsUint) {
				n.Uint64 = new Go$Uint64(0, n.Float64);
			}
		}
	};
	NumberNode.prototype.simplifyComplex = function() { return this.go$val.simplifyComplex(); };
 0
NumberNodesimplifyComplex0#0!text/template/parse
NumberNode0Å‡ Å¶	NumberNode.Ptr.prototype.String = function() {
		var n;
		n = this;
		return n.Text;
	};
	NumberNode.prototype.String = function() { return this.go$val.String(); };
 0
NumberNode0#0!text/template/parse
NumberNode0Ç€ Ç†	NumberNode.Ptr.prototype.Copy = function() {
		var n, nn, _struct, l, r;
		n = this;
		nn = new NumberNode.Ptr();
		l = nn, r = (_struct = n, new NumberNode.Ptr(_struct.NodeType, _struct.Pos, _struct.IsInt, _struct.IsUint, _struct.IsFloat, _struct.IsComplex, _struct.Int64, _struct.Uint64, _struct.Float64, _struct.Complex128, _struct.Text)), l.NodeType = r.NodeType, l.Pos = r.Pos, l.IsInt = r.IsInt, l.IsUint = r.IsUint, l.IsFloat = r.IsFloat, l.IsComplex = r.IsComplex, l.Int64 = r.Int64, l.Uint64 = r.Uint64, l.Float64 = r.Float64, l.Complex128 = r.Complex128, l.Text = r.Text;
		return nn;
	};
	NumberNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0
NumberNode0#0!text/template/parse
NumberNode0Å†	newString_	newString = function(pos, orig, text) {
		return new StringNode.Ptr(16, pos, orig, text);
	};
 0	newString0#0!text/template/parse
StringNode0Å‚ Å®	StringNode.Ptr.prototype.String = function() {
		var s;
		s = this;
		return s.Quoted;
	};
	StringNode.prototype.String = function() { return this.go$val.String(); };
 0
StringNode0#0!text/template/parse
StringNode0Ç Åº	StringNode.Ptr.prototype.Copy = function() {
		var s;
		s = this;
		return newString(s.Pos, s.Quoted, s.Text);
	};
	StringNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0
StringNode0E0!text/template/parse
StringNode0 text/template/parse	newString0unewEnd=	newEnd = function(pos) {
		return new endNode.Ptr(pos);
	};
 0newEnd0 0text/template/parseendNode0Å… Åï	endNode.Ptr.prototype.Type = function() {
		var e;
		e = this;
		return 7;
	};
	endNode.prototype.Type = function() { return this.go$val.Type(); };
 0	endNode0 0text/template/parseendNode0Å◊ Å£	endNode.Ptr.prototype.String = function() {
		var e;
		e = this;
		return "{{end}}";
	};
	endNode.prototype.String = function() { return this.go$val.String(); };
 0	endNode0 0text/template/parseendNode0ÅÙ Å°	endNode.Ptr.prototype.Copy = function() {
		var e;
		e = this;
		return newEnd(e.Pos);
	};
	endNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0	endNode0?0text/template/parseendNode0text/template/parsenewEnd0ÅânewElseN	newElse = function(pos, line) {
		return new elseNode.Ptr(6, pos, line);
	};
 0	newElse0!0text/template/parseelseNode0ÅÕ Åó	elseNode.Ptr.prototype.Type = function() {
		var e;
		e = this;
		return 6;
	};
	elseNode.prototype.Type = function() { return this.go$val.Type(); };
 0
elseNode0!0text/template/parseelseNode0Å‹ Å¶	elseNode.Ptr.prototype.String = function() {
		var e;
		e = this;
		return "{{else}}";
	};
	elseNode.prototype.String = function() { return this.go$val.String(); };
 0
elseNode0!0text/template/parseelseNode0Ç Å¨	elseNode.Ptr.prototype.Copy = function() {
		var e;
		e = this;
		return newElse(e.Pos, e.Line);
	};
	elseNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0
elseNode0A0text/template/parseelseNode0text/template/parsenewElse0Ç> Ç“	BranchNode.Ptr.prototype.String = function() {
		var b, name, _ref;
		b = this;
		name = "";
		_ref = b.NodeType;
		if (_ref === 10) {
			name = "if";
		} else if (_ref === 15) {
			name = "range";
		} else if (_ref === 19) {
			name = "with";
		} else {
			throw go$panic(new Go$String("unknown branch type"));
		}
		if (!(b.ElseList === (go$ptrType(ListNode)).nil)) {
			return fmt.Sprintf("{{%s %s}}%s{{else}}%s{{end}}", new (go$sliceType(go$emptyInterface))([new Go$String(name), b.Pipe, b.List, b.ElseList]));
		}
		return fmt.Sprintf("{{%s %s}}%s{{end}}", new (go$sliceType(go$emptyInterface))([new Go$String(name), b.Pipe, b.List]));
	};
	BranchNode.prototype.String = function() { return this.go$val.String(); };
 0
BranchNode0T0!text/template/parse
BranchNode0text/template/parseListNode0fmtSprintf0Ç+newIfÅè	newIf = function(pos, line, pipe, list$1, elseList) {
		return new IfNode.Ptr(new BranchNode.Ptr(10, pos, line, pipe, list$1, elseList));
	};
 0newIf0ÅÑ0text/template/parsePipeNode0text/template/parseListNode0!text/template/parse
BranchNode0text/template/parseIfNode0Çk Ç	IfNode.Ptr.prototype.Copy = function() {
		var i;
		i = this;
		return newIf(i.BranchNode.Pos, i.BranchNode.Line, i.BranchNode.Pipe.CopyPipe(), i.BranchNode.List.CopyList(), i.BranchNode.ElseList.CopyList());
	};
	IfNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0IfNode0=0text/template/parseIfNode0text/template/parsenewIf0Ç:newRangeÅï	newRange = function(pos, line, pipe, list$1, elseList) {
		return new RangeNode.Ptr(new BranchNode.Ptr(15, pos, line, pipe, list$1, elseList));
	};
 0
newRange0Åá0text/template/parsePipeNode0text/template/parseListNode0!text/template/parse
BranchNode0 text/template/parse	RangeNode0Ç} Ç#	RangeNode.Ptr.prototype.Copy = function() {
		var r;
		r = this;
		return newRange(r.BranchNode.Pos, r.BranchNode.Line, r.BranchNode.Pipe.CopyPipe(), r.BranchNode.List.CopyList(), r.BranchNode.ElseList.CopyList());
	};
	RangeNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0	RangeNode0C0 text/template/parse	RangeNode0text/template/parsenewRange0Ç5newWithÅì	newWith = function(pos, line, pipe, list$1, elseList) {
		return new WithNode.Ptr(new BranchNode.Ptr(19, pos, line, pipe, list$1, elseList));
	};
 0	newWith0ÅÜ0text/template/parsePipeNode0text/template/parseListNode0!text/template/parse
BranchNode0text/template/parseWithNode0Çw Ç 	WithNode.Ptr.prototype.Copy = function() {
		var w;
		w = this;
		return newWith(w.BranchNode.Pos, w.BranchNode.Line, w.BranchNode.Pipe.CopyPipe(), w.BranchNode.List.CopyList(), w.BranchNode.ElseList.CopyList());
	};
	WithNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0
WithNode0A0text/template/parseWithNode0text/template/parsenewWith0Å◊newTemplateo	newTemplate = function(pos, line, name, pipe) {
		return new TemplateNode.Ptr(17, pos, line, name, pipe);
	};
 0newTemplate0F0text/template/parsePipeNode0#text/template/parseTemplateNode0Ç Ç™	TemplateNode.Ptr.prototype.String = function() {
		var t;
		t = this;
		if (t.Pipe === (go$ptrType(PipeNode)).nil) {
			return fmt.Sprintf("{{template %q}}", new (go$sliceType(go$emptyInterface))([new Go$String(t.Name)]));
		}
		return fmt.Sprintf("{{template %q %s}}", new (go$sliceType(go$emptyInterface))([new Go$String(t.Name), t.Pipe]));
	};
	TemplateNode.prototype.String = function() { return this.go$val.String(); };
 0TemplateNode0V0#text/template/parseTemplateNode0text/template/parsePipeNode0fmtSprintf0Ç5 Å”	TemplateNode.Ptr.prototype.Copy = function() {
		var t;
		t = this;
		return newTemplate(t.Pos, t.Line, t.Name, t.Pipe.CopyPipe());
	};
	TemplateNode.prototype.Copy = function() { return this.go$val.Copy(); };
 0TemplateNode0I0#text/template/parseTemplateNode0"text/template/parsenewTemplate0Çd ÇŸ	Tree.Ptr.prototype.Copy = function() {
		var t;
		t = this;
		if (t === (go$ptrType(Tree)).nil) {
			return (go$ptrType(Tree)).nil;
		}
		return new Tree.Ptr(t.Name, t.ParseName, t.Root.CopyList(), t.text, (go$sliceType((go$mapType(Go$String, go$emptyInterface)))).nil, (go$ptrType(lexer)).nil, go$makeNativeArray("Struct", 3, function() { return new item.Ptr(); }), 0, (go$sliceType(Go$String)).nil);
	};
	Tree.prototype.Copy = function() { return this.go$val.Copy(); };
 0Tree0y0text/template/parseTree0text/template/parseListNode0text/template/parselexer0text/template/parseitem0Ç∞ParseÇ|	Parse = go$pkg.Parse = function(name, text, leftDelim, rightDelim, funcs) {
		var treeSet, err, t, _tuple;
		treeSet = false;
		err = null;
		treeSet = new Go$Map();
		t = New(name, new (go$sliceType((go$mapType(Go$String, go$emptyInterface))))([]));
		t.text = text;
		_tuple = t.Parse(text, leftDelim, rightDelim, treeSet, funcs), err = _tuple[1];
		return [treeSet, err];
	};
 0Parse00text/template/parseNew0Ç$ Ç±	Tree.Ptr.prototype.next = function() {
		var t, _struct, _struct$1;
		t = this;
		if (t.peekCount > 0) {
			t.peekCount = t.peekCount - 1 >> 0;
		} else {
			t.token[0] = (_struct = t.lex.nextItem(), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		}
		return (_struct$1 = t.token[t.peekCount], new item.Ptr(_struct$1.typ, _struct$1.pos, _struct$1.val));
	};
	Tree.prototype.next = function() { return this.go$val.next(); };
 0Treenext0[0text/template/parseTree0text/template/parsenextItem0text/template/parseitem0ÅÂ ÅØ	Tree.Ptr.prototype.backup = function() {
		var t;
		t = this;
		t.peekCount = t.peekCount + 1 >> 0;
	};
	Tree.prototype.backup = function() { return this.go$val.backup(); };
 0Treebackup00text/template/parseTree0ÇW Ç	Tree.Ptr.prototype.backup2 = function(t1) {
		var t, _struct;
		t = this;
		t.token[1] = (_struct = t1, new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		t.peekCount = 2;
	};
	Tree.prototype.backup2 = function(t1) { return this.go$val.backup2(t1); };
 0Treebackup20:0text/template/parseTree0text/template/parseitem0Ç  Çu	Tree.Ptr.prototype.backup3 = function(t2, t1) {
		var t, _struct, _struct$1;
		t = this;
		t.token[1] = (_struct = t1, new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		t.token[2] = (_struct$1 = t2, new item.Ptr(_struct$1.typ, _struct$1.pos, _struct$1.val));
		t.peekCount = 3;
	};
	Tree.prototype.backup3 = function(t2, t1) { return this.go$val.backup3(t2, t1); };
 0Treebackup30:0text/template/parseTree0text/template/parseitem0Çy Ç	Tree.Ptr.prototype.peek = function() {
		var t, _struct, _struct$1, _struct$2;
		t = this;
		if (t.peekCount > 0) {
			return (_struct = t.token[(t.peekCount - 1 >> 0)], new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		}
		t.peekCount = 1;
		t.token[0] = (_struct$1 = t.lex.nextItem(), new item.Ptr(_struct$1.typ, _struct$1.pos, _struct$1.val));
		return (_struct$2 = t.token[0], new item.Ptr(_struct$2.typ, _struct$2.pos, _struct$2.val));
	};
	Tree.prototype.peek = function() { return this.go$val.peek(); };
 0Treepeek0[0text/template/parseTree0text/template/parseitem0text/template/parsenextItem0Ç† Ç)	Tree.Ptr.prototype.nextNonSpace = function() {
		var token, t, _struct, _struct$1, _struct$2;
		token = new item.Ptr();
		t = this;
		while (true) {
			token = (_struct = t.next(), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
			if (!((token.typ === 16))) {
				break;
			}
		}
		token = (_struct$1 = token, new item.Ptr(_struct$1.typ, _struct$1.pos, _struct$1.val));
		return (_struct$2 = token, new item.Ptr(_struct$2.typ, _struct$2.pos, _struct$2.val));
	};
	Tree.prototype.nextNonSpace = function() { return this.go$val.nextNonSpace(); };
 0TreenextNonSpace0W0text/template/parseTree0text/template/parseitem0text/template/parsenext0ÇÕ Ç7	Tree.Ptr.prototype.peekNonSpace = function() {
		var token, t, _struct, _struct$1, _struct$2;
		token = new item.Ptr();
		t = this;
		while (true) {
			token = (_struct = t.next(), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
			if (!((token.typ === 16))) {
				break;
			}
		}
		t.backup();
		token = (_struct$1 = token, new item.Ptr(_struct$1.typ, _struct$1.pos, _struct$1.val));
		return (_struct$2 = token, new item.Ptr(_struct$2.typ, _struct$2.pos, _struct$2.val));
	};
	Tree.prototype.peekNonSpace = function() { return this.go$val.peekNonSpace(); };
 0TreepeekNonSpace0v0text/template/parseTree0text/template/parseitem0text/template/parsenext0text/template/parsebackup0ÇáNewÅ˚	New = go$pkg.New = function(name, funcs) {
		return new Tree.Ptr(name, "", (go$ptrType(ListNode)).nil, "", funcs, (go$ptrType(lexer)).nil, go$makeNativeArray("Struct", 3, function() { return new item.Ptr(); }), 0, (go$sliceType(Go$String)).nil);
	};
 0New0y0text/template/parseListNode0text/template/parselexer0text/template/parseitem0text/template/parseTree0Ç˘ Çí	Tree.Ptr.prototype.ErrorContext = function(n) {
		var location, context, t, pos, text, byteNum, lineNum, _tuple;
		location = "";
		context = "";
		t = this;
		pos = (n.Position() >> 0);
		text = t.text.substring(0, pos);
		byteNum = strings.LastIndex(text, "\n");
		if (byteNum === -1) {
			byteNum = pos;
		} else {
			byteNum = byteNum + 1 >> 0;
			byteNum = pos - byteNum >> 0;
		}
		lineNum = 1 + strings.Count(text, "\n") >> 0;
		context = n.String();
		if (context.length > 20) {
			context = fmt.Sprintf("%.20s...", new (go$sliceType(go$emptyInterface))([new Go$String(context)]));
		}
		_tuple = [fmt.Sprintf("%s:%d:%d", new (go$sliceType(go$emptyInterface))([new Go$String(t.ParseName), new Go$Int(lineNum), new Go$Int(byteNum)])), context], location = _tuple[0], context = _tuple[1];
		return [location, context];
	};
	Tree.prototype.ErrorContext = function(n) { return this.go$val.ErrorContext(n); };
 0Tree0U0text/template/parseTree0strings	LastIndex0stringsCount0fmtSprintf0ÇF Ç´	Tree.Ptr.prototype.errorf = function(format, args) {
		var t;
		t = this;
		t.Root = (go$ptrType(ListNode)).nil;
		format = fmt.Sprintf("template: %s:%d: %s", new (go$sliceType(go$emptyInterface))([new Go$String(t.ParseName), new Go$Int(t.lex.lineNumber()), new Go$String(format)]));
		throw go$panic(fmt.Errorf(format, args));
	};
	Tree.prototype.errorf = function(format, args) { return this.go$val.errorf(format, args); };
 0Treeerrorf0ÅÄ0text/template/parseTree0text/template/parseListNode0fmtSprintf0!text/template/parse
lineNumber0fmtErrorf0Ç# Åœ	Tree.Ptr.prototype.error = function(err) {
		var t;
		t = this;
		t.errorf("%s", new (go$sliceType(go$emptyInterface))([err]));
	};
	Tree.prototype.error = function(err) { return this.go$val.error(err); };
 0Treeerror0<0text/template/parseTree0text/template/parseerrorf0Ç» Ç+	Tree.Ptr.prototype.expect = function(expected, context) {
		var t, _struct, token, _struct$1, _struct$2;
		t = this;
		token = (_struct = t.nextNonSpace(), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		if (!((token.typ === expected))) {
			t.unexpected((_struct$1 = token, new item.Ptr(_struct$1.typ, _struct$1.pos, _struct$1.val)), context);
		}
		return (_struct$2 = token, new item.Ptr(_struct$2.typ, _struct$2.pos, _struct$2.val));
	};
	Tree.prototype.expect = function(expected, context) { return this.go$val.expect(expected, context); };
 0Treeexpect0ÅÇ0text/template/parseTree0#text/template/parsenextNonSpace0text/template/parseitem0!text/template/parse
unexpected0Ç! Ç	Tree.Ptr.prototype.expectOneOf = function(expected1, expected2, context) {
		var t, _struct, token, _struct$1, _struct$2;
		t = this;
		token = (_struct = t.nextNonSpace(), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		if (!((token.typ === expected1)) && !((token.typ === expected2))) {
			t.unexpected((_struct$1 = token, new item.Ptr(_struct$1.typ, _struct$1.pos, _struct$1.val)), context);
		}
		return (_struct$2 = token, new item.Ptr(_struct$2.typ, _struct$2.pos, _struct$2.val));
	};
	Tree.prototype.expectOneOf = function(expected1, expected2, context) { return this.go$val.expectOneOf(expected1, expected2, context); };
 0TreeexpectOneOf0ÅÇ0text/template/parseTree0#text/template/parsenextNonSpace0text/template/parseitem0!text/template/parse
unexpected0Ç¢ ÇH	Tree.Ptr.prototype.unexpected = function(token, context) {
		var t;
		t = this;
		t.errorf("unexpected %s in %s", new (go$sliceType(go$emptyInterface))([new token.constructor.Struct(token), new Go$String(context)]));
	};
	Tree.prototype.unexpected = function(token, context) { return this.go$val.unexpected(token, context); };
 0Tree
unexpected0<0text/template/parseTree0text/template/parseerrorf0Ç… Ç]	Tree.Ptr.prototype.recover = function(errp) {
		var t, e, ok, _tuple;
		t = this;
		e = go$recover();
		if (!(go$interfaceIsEqual(e, null))) {
			if (_tuple = (e !== null && runtime.Error.implementedBy.indexOf(e.constructor) !== -1 ? [e, true] : [null, false]), ok = _tuple[1], ok) {
				throw go$panic(e);
			}
			if (!(t === (go$ptrType(Tree)).nil)) {
				t.stopParse();
			}
			errp.go$set((e !== null && go$error.implementedBy.indexOf(e.constructor) !== -1 ? e : go$typeAssertionFailed(e, go$error)));
		}
		return;
	};
	Tree.prototype.recover = function(errp) { return this.go$val.recover(errp); };
 0Treerecover0Q0text/template/parseTree0runtimeError0 text/template/parse	stopParse0Çë Ç5	Tree.Ptr.prototype.startParse = function(funcs, lex$1) {
		var t;
		t = this;
		t.Root = (go$ptrType(ListNode)).nil;
		t.lex = lex$1;
		t.vars = new (go$sliceType(Go$String))(["$"]);
		t.funcs = funcs;
	};
	Tree.prototype.startParse = function(funcs, lex$1) { return this.go$val.startParse(funcs, lex$1); };
 0Tree
startParse0>0text/template/parseTree0text/template/parseListNode0ÇÉ Ç+	Tree.Ptr.prototype.stopParse = function() {
		var t;
		t = this;
		t.lex = (go$ptrType(lexer)).nil;
		t.vars = (go$sliceType(Go$String)).nil;
		t.funcs = (go$sliceType((go$mapType(Go$String, go$emptyInterface)))).nil;
	};
	Tree.prototype.stopParse = function() { return this.go$val.stopParse(); };
 0Tree	stopParse0;0text/template/parseTree0text/template/parselexer0ÇT Çi	Tree.Ptr.prototype.Parse = function(text, leftDelim, rightDelim, treeSet, funcs) {
		var tree, err, t, v, _tuple;
		tree = (go$ptrType(Tree)).nil;
		err = null;
		var go$deferred = [];
		try {
			t = this;
			go$deferred.push({ recv: t, method: "recover", args: [new (go$ptrType(go$error))(function() { return err; }, function(v) { err = v; })] });
			t.ParseName = t.Name;
			t.startParse(funcs, lex(t.Name, text, leftDelim, rightDelim));
			t.text = text;
			t.parse(treeSet);
			t.add(treeSet);
			t.stopParse();
			_tuple = [t, null], tree = _tuple[0], err = _tuple[1];
			return [tree, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [tree, err];
		}
	};
	Tree.prototype.Parse = function(text, leftDelim, rightDelim, treeSet, funcs) { return this.go$val.Parse(text, leftDelim, rightDelim, treeSet, funcs); };
 0Tree0Åÿ0text/template/parseTree0text/template/parserecover0!text/template/parse
startParse0text/template/parselex0text/template/parseparse0text/template/parseadd0 text/template/parse	stopParse0Ç· Çj	Tree.Ptr.prototype.add = function(treeSet) {
		var t, _entry, tree, _key;
		t = this;
		tree = (_entry = treeSet[t.Name], _entry !== undefined ? _entry.v : (go$ptrType(Tree)).nil);
		if (tree === (go$ptrType(Tree)).nil || IsEmptyTree(tree.Root)) {
			_key = t.Name, (treeSet || go$throwRuntimeError("assignment to entry in nil map"))[_key] = { k: _key, v: t };
			return;
		}
		if (!IsEmptyTree(t.Root)) {
			t.errorf("template: multiple definition of template %q", new (go$sliceType(go$emptyInterface))([new Go$String(t.Name)]));
		}
	};
	Tree.prototype.add = function(treeSet) { return this.go$val.add(treeSet); };
 0Treeadd0`0text/template/parseTree0"text/template/parseIsEmptyTree0text/template/parseerrorf0ÇÂIsEmptyTreeÇø	IsEmptyTree = go$pkg.IsEmptyTree = function(n) {
		var n$1, _ref, _type, _ref$1, _i, _slice, _index, node;
		_ref = n;
		_type = _ref !== null ? _ref.constructor : null;
		if (_type === null) {
			n$1 = _ref;
			return true;
		} else if (_type === (go$ptrType(ActionNode))) {
			n$1 = _ref.go$val;
		} else if (_type === (go$ptrType(IfNode))) {
			n$1 = _ref.go$val;
		} else if (_type === (go$ptrType(ListNode))) {
			n$1 = _ref.go$val;
			_ref$1 = n$1.Nodes;
			_i = 0;
			while (_i < _ref$1.length) {
				node = (_slice = _ref$1, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				if (!IsEmptyTree(node)) {
					return false;
				}
				_i++;
			}
			return true;
		} else if (_type === (go$ptrType(RangeNode))) {
			n$1 = _ref.go$val;
		} else if (_type === (go$ptrType(TemplateNode))) {
			n$1 = _ref.go$val;
		} else if (_type === (go$ptrType(TextNode))) {
			n$1 = _ref.go$val;
			return bytes.TrimSpace(n$1.Text).length === 0;
		} else if (_type === (go$ptrType(WithNode))) {
			n$1 = _ref.go$val;
		} else {
			n$1 = _ref;
			throw go$panic(new Go$String("unknown node: " + n$1.String()));
		}
		return false;
	};
 0IsEmptyTree0Ç 0text/template/parseIfNode0 text/template/parse	RangeNode0text/template/parseTextNode0text/template/parseWithNode0!text/template/parse
ActionNode0text/template/parseListNode0#text/template/parseTemplateNode0bytes	TrimSpace0Çé Ç–	Tree.Ptr.prototype.parse = function(treeSet) {
		var next, t, _struct, delim, newT, _struct$1, n;
		next = null;
		t = this;
		t.Root = newList(t.peek().pos);
		while (!((t.peek().typ === 6))) {
			if (t.peek().typ === 9) {
				delim = (_struct = t.next(), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
				if (t.nextNonSpace().typ === 22) {
					newT = New("definition", new (go$sliceType((go$mapType(Go$String, go$emptyInterface))))([]));
					newT.text = t.text;
					newT.ParseName = t.ParseName;
					newT.startParse(t.funcs, t.lex);
					newT.parseDefinition(treeSet);
					continue;
				}
				t.backup2((_struct$1 = delim, new item.Ptr(_struct$1.typ, _struct$1.pos, _struct$1.val)));
			}
			n = t.textOrAction();
			if (n.Type() === 7) {
				t.errorf("unexpected %s", new (go$sliceType(go$emptyInterface))([n]));
			}
			t.Root.append(n);
		}
		next = null;
		return next;
	};
	Tree.prototype.parse = function(treeSet) { return this.go$val.parse(treeSet); };
 0Treeparse0Ç£0#text/template/parsenextNonSpace0text/template/parseNew0!text/template/parse
startParse0text/template/parsebackup20text/template/parseappend0text/template/parseTree0text/template/parsenewList0text/template/parsepeek0text/template/parsenext0text/template/parseitem0&text/template/parseparseDefinition0#text/template/parsetextOrAction0text/template/parseerrorf0Çl Ç	Tree.Ptr.prototype.parseDefinition = function(treeSet) {
		var t, _struct, name, err, _tuple, end, _tuple$1;
		t = this;
		name = (_struct = t.expectOneOf(17, 13, "define clause"), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		err = null;
		_tuple = strconv.Unquote(name.val), t.Name = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			t.error(err);
		}
		t.expect(14, "define clause");
		end = null;
		_tuple$1 = t.itemList(), t.Root = _tuple$1[0], end = _tuple$1[1];
		if (!((end.Type() === 7))) {
			t.errorf("unexpected %s in %s", new (go$sliceType(go$emptyInterface))([end, new Go$String("define clause")]));
		}
		t.add(treeSet);
		t.stopParse();
	};
	Tree.prototype.parseDefinition = function(treeSet) { return this.go$val.parseDefinition(treeSet); };
 0TreeparseDefinition0Ç-0"text/template/parseexpectOneOf0text/template/parseitem0text/template/parseerror0text/template/parseadd0 text/template/parse	stopParse0text/template/parseTree0strconvUnquote0text/template/parseexpect0text/template/parseitemList0text/template/parseerrorf0Çh Çe	Tree.Ptr.prototype.itemList = function() {
		var list$1, next, t, n, _ref, _tuple;
		list$1 = (go$ptrType(ListNode)).nil;
		next = null;
		t = this;
		list$1 = newList(t.peekNonSpace().pos);
		while (!((t.peekNonSpace().typ === 6))) {
			n = t.textOrAction();
			_ref = n.Type();
			if (_ref === 7 || _ref === 6) {
				_tuple = [list$1, n], list$1 = _tuple[0], next = _tuple[1];
				return [list$1, next];
			}
			list$1.append(n);
		}
		t.errorf("unexpected EOF", new (go$sliceType(go$emptyInterface))([]));
		return [list$1, next];
	};
	Tree.prototype.itemList = function() { return this.go$val.itemList(); };
 0TreeitemList0ÅÊ0text/template/parseTree0text/template/parseListNode0text/template/parsenewList0#text/template/parsepeekNonSpace0#text/template/parsetextOrAction0text/template/parseappend0text/template/parseerrorf0Ç Ç$	Tree.Ptr.prototype.textOrAction = function() {
		var t, _struct, token, _ref, _struct$1;
		t = this;
		token = (_struct = t.nextNonSpace(), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		_ref = token.typ;
		if (_ref === 18) {
			return newText(token.pos, token.val);
		} else if (_ref === 9) {
			return t.action();
		} else {
			t.unexpected((_struct$1 = token, new item.Ptr(_struct$1.typ, _struct$1.pos, _struct$1.val)), "input");
		}
		return null;
	};
	Tree.prototype.textOrAction = function() { return this.go$val.textOrAction(); };
 0TreetextOrAction0Å¡0text/template/parseTree0#text/template/parsenextNonSpace0text/template/parseitem0text/template/parsenewText0text/template/parseaction0!text/template/parse
unexpected0Çˇ Ç	Tree.Ptr.prototype.action = function() {
		var n, t, _struct, token, _ref;
		n = null;
		t = this;
		token = (_struct = t.nextNonSpace(), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		_ref = token.typ;
		if (_ref === 23) {
			n = t.elseControl();
			return n;
		} else if (_ref === 24) {
			n = t.endControl();
			return n;
		} else if (_ref === 25) {
			n = t.ifControl();
			return n;
		} else if (_ref === 27) {
			n = t.rangeControl();
			return n;
		} else if (_ref === 28) {
			n = t.templateControl();
			return n;
		} else if (_ref === 29) {
			n = t.withControl();
			return n;
		}
		t.backup();
		n = newAction(t.peek().pos, t.lex.lineNumber(), t.pipeline("command"));
		return n;
	};
	Tree.prototype.action = function() { return this.go$val.action(); };
 0Treeaction0Ç€0text/template/parseTree0text/template/parsepeek0text/template/parseitem0"text/template/parseelseControl0"text/template/parsewithControl0!text/template/parse
lineNumber0#text/template/parserangeControl0text/template/parsebackup0 text/template/parse	newAction0text/template/parsepipeline0#text/template/parsenextNonSpace0!text/template/parse
endControl0 text/template/parse	ifControl0&text/template/parsetemplateControl0Çﬂ Ç	r	Tree.Ptr.prototype.pipeline = function(context) {
		var pipe, t, decl, pos, v, _struct, _struct$1, tokenAfterVariable, next, _struct$2, variable, _struct$3, _struct$4, _struct$5, _struct$6, token, _ref, _struct$7;
		pipe = (go$ptrType(PipeNode)).nil;
		t = this;
		decl = (go$sliceType((go$ptrType(VariableNode)))).nil;
		pos = t.peekNonSpace().pos;
		while (true) {
			if (v = (_struct = t.peekNonSpace(), new item.Ptr(_struct.typ, _struct.pos, _struct.val)), v.typ === 19) {
				t.next();
				tokenAfterVariable = (_struct$1 = t.peek(), new item.Ptr(_struct$1.typ, _struct$1.pos, _struct$1.val));
				if (next = (_struct$2 = t.peekNonSpace(), new item.Ptr(_struct$2.typ, _struct$2.pos, _struct$2.val)), (next.typ === 5) || ((next.typ === 2) && next.val === ",")) {
					t.nextNonSpace();
					variable = newVariable(v.pos, v.val);
					decl = go$append(decl, variable);
					t.vars = go$append(t.vars, v.val);
					if ((next.typ === 2) && next.val === ",") {
						if (context === "range" && decl.length < 2) {
							continue;
						}
						t.errorf("too many declarations in %s", new (go$sliceType(go$emptyInterface))([new Go$String(context)]));
					}
				} else if (tokenAfterVariable.typ === 16) {
					t.backup3((_struct$3 = v, new item.Ptr(_struct$3.typ, _struct$3.pos, _struct$3.val)), (_struct$4 = tokenAfterVariable, new item.Ptr(_struct$4.typ, _struct$4.pos, _struct$4.val)));
				} else {
					t.backup2((_struct$5 = v, new item.Ptr(_struct$5.typ, _struct$5.pos, _struct$5.val)));
				}
			}
			break;
		}
		pipe = newPipeline(pos, t.lex.lineNumber(), decl);
		while (true) {
			token = (_struct$6 = t.nextNonSpace(), new item.Ptr(_struct$6.typ, _struct$6.pos, _struct$6.val));
			_ref = token.typ;
			if (_ref === 14 || _ref === 15) {
				if (pipe.Cmds.length === 0) {
					t.errorf("missing value for %s", new (go$sliceType(go$emptyInterface))([new Go$String(context)]));
				}
				if (token.typ === 15) {
					t.backup();
				}
				return pipe;
			} else if (_ref === 1 || _ref === 3 || _ref === 4 || _ref === 21 || _ref === 7 || _ref === 8 || _ref === 11 || _ref === 26 || _ref === 13 || _ref === 17 || _ref === 19 || _ref === 10) {
				t.backup();
				pipe.append(t.command());
			} else {
				t.unexpected((_struct$7 = token, new item.Ptr(_struct$7.typ, _struct$7.pos, _struct$7.val)), context);
			}
		}
	};
	Tree.prototype.pipeline = function(context) { return this.go$val.pipeline(context); };
 0Treepipeline0ÇO0text/template/parsePipeNode0text/template/parsepeek0"text/template/parsenewPipeline0!text/template/parse
lineNumber0text/template/parsebackup0!text/template/parse
unexpected0text/template/parseTree0#text/template/parseVariableNode0text/template/parseitem0text/template/parsenext0text/template/parsebackup30text/template/parsecommand0#text/template/parsepeekNonSpace0#text/template/parsenextNonSpace0"text/template/parsenewVariable0text/template/parseerrorf0text/template/parsebackup20text/template/parseappend0Ç◊ Ç˚	Tree.Ptr.prototype.parseControl = function(allowElseIf, context) {
		var pos, line, pipe, list$1, elseList, t, next, _tuple, _ref, _tuple$1, _tuple$2;
		pos = 0;
		line = 0;
		pipe = (go$ptrType(PipeNode)).nil;
		list$1 = (go$ptrType(ListNode)).nil;
		elseList = (go$ptrType(ListNode)).nil;
		var go$deferred = [];
		try {
			t = this;
			go$deferred.push({ recv: t, method: "popVars", args: [t.vars.length] });
			line = t.lex.lineNumber();
			pipe = t.pipeline(context);
			next = null;
			_tuple = t.itemList(), list$1 = _tuple[0], next = _tuple[1];
			_ref = next.Type();
			switch (0) { default: if (_ref === 7) {
			} else if (_ref === 6) {
				if (allowElseIf) {
					if (t.peek().typ === 25) {
						t.next();
						elseList = newList(next.Position());
						elseList.append(t.ifControl());
						break;
					}
				}
				_tuple$1 = t.itemList(), elseList = _tuple$1[0], next = _tuple$1[1];
				if (!((next.Type() === 7))) {
					t.errorf("expected end; found %s", new (go$sliceType(go$emptyInterface))([next]));
				}
			} }
			_tuple$2 = [(new Pos(pipe.Pos)).Position(), line, pipe, list$1, elseList], pos = _tuple$2[0], line = _tuple$2[1], pipe = _tuple$2[2], list$1 = _tuple$2[3], elseList = _tuple$2[4];
			return [pos, line, pipe, list$1, elseList];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [pos, line, pipe, list$1, elseList];
		}
	};
	Tree.prototype.parseControl = function(allowElseIf, context) { return this.go$val.parseControl(allowElseIf, context); };
 0TreeparseControl0Ç∫0text/template/parsepopVars0text/template/parseitemList0 text/template/parse	ifControl0text/template/parseTree0text/template/parsePipeNode0!text/template/parse
lineNumber0text/template/parsepipeline0text/template/parsepeek0text/template/parseListNode0text/template/parsenext0text/template/parsenewList0text/template/parseappend0text/template/parseerrorf0text/template/parsePos0ÇÖ Ç	Tree.Ptr.prototype.ifControl = function() {
		var t, _tuple;
		t = this;
		return (_tuple = t.parseControl(true, "if"), newIf(_tuple[0], _tuple[1], _tuple[2], _tuple[3], _tuple[4]));
	};
	Tree.prototype.ifControl = function() { return this.go$val.ifControl(); };
 0Tree	ifControl0`0text/template/parseTree0text/template/parsenewIf0#text/template/parseparseControl0Çõ Ç	Tree.Ptr.prototype.rangeControl = function() {
		var t, _tuple;
		t = this;
		return (_tuple = t.parseControl(false, "range"), newRange(_tuple[0], _tuple[1], _tuple[2], _tuple[3], _tuple[4]));
	};
	Tree.prototype.rangeControl = function() { return this.go$val.rangeControl(); };
 0TreerangeControl0c0text/template/parseTree0text/template/parsenewRange0#text/template/parseparseControl0Çî Ç	Tree.Ptr.prototype.withControl = function() {
		var t, _tuple;
		t = this;
		return (_tuple = t.parseControl(false, "with"), newWith(_tuple[0], _tuple[1], _tuple[2], _tuple[3], _tuple[4]));
	};
	Tree.prototype.withControl = function() { return this.go$val.withControl(); };
 0TreewithControl0b0text/template/parseTree0text/template/parsenewWith0#text/template/parseparseControl0Ç7 Åø	Tree.Ptr.prototype.endControl = function() {
		var t;
		t = this;
		return newEnd(t.expect(14, "end").pos);
	};
	Tree.prototype.endControl = function() { return this.go$val.endControl(); };
 0Tree
endControl0[0text/template/parseTree0text/template/parsenewEnd0text/template/parseexpect0Çr Çë	Tree.Ptr.prototype.elseControl = function() {
		var t, _struct, peek;
		t = this;
		peek = (_struct = t.peekNonSpace(), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		if (peek.typ === 25) {
			return newElse(peek.pos, t.lex.lineNumber());
		}
		return newElse(t.expect(14, "else").pos, t.lex.lineNumber());
	};
	Tree.prototype.elseControl = function() { return this.go$val.elseControl(); };
 0TreeelseControl0Å¡0text/template/parseTree0#text/template/parsepeekNonSpace0text/template/parseitem0text/template/parsenewElse0!text/template/parse
lineNumber0text/template/parseexpect0ÇË Çg	Tree.Ptr.prototype.templateControl = function() {
		var t, name, _struct, token, _ref, _tuple, s, err, _struct$1, pipe;
		t = this;
		name = "";
		token = (_struct = t.nextNonSpace(), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		_ref = token.typ;
		if (_ref === 17 || _ref === 13) {
			_tuple = strconv.Unquote(token.val), s = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				t.error(err);
			}
			name = s;
		} else {
			t.unexpected((_struct$1 = token, new item.Ptr(_struct$1.typ, _struct$1.pos, _struct$1.val)), "template invocation");
		}
		pipe = (go$ptrType(PipeNode)).nil;
		if (!((t.nextNonSpace().typ === 14))) {
			t.backup();
			pipe = t.pipeline("template");
		}
		return newTemplate(token.pos, t.lex.lineNumber(), name, pipe);
	};
	Tree.prototype.templateControl = function() { return this.go$val.templateControl(); };
 0TreetemplateControl0Ç\0!text/template/parse
unexpected0text/template/parsebackup0"text/template/parsenewTemplate0!text/template/parse
lineNumber0text/template/parseTree0#text/template/parsenextNonSpace0text/template/parseitem0strconvUnquote0text/template/parseerror0text/template/parsePipeNode0text/template/parsepipeline0Ç Ç‰	Tree.Ptr.prototype.command = function() {
		var t, cmd, operand, _struct, token, _ref;
		t = this;
		cmd = newCommand(t.peekNonSpace().pos);
		while (true) {
			t.peekNonSpace();
			operand = t.operand();
			if (!(go$interfaceIsEqual(operand, null))) {
				cmd.append(operand);
			}
			token = (_struct = t.next(), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
			_ref = token.typ;
			if (_ref === 16) {
				continue;
			} else if (_ref === 0) {
				t.errorf("%s", new (go$sliceType(go$emptyInterface))([new Go$String(token.val)]));
			} else if (_ref === 14 || _ref === 15) {
				t.backup();
			} else if (_ref === 12) {
			} else {
				t.errorf("unexpected %s in operand; missing space?", new (go$sliceType(go$emptyInterface))([new token.constructor.Struct(token)]));
			}
			break;
		}
		if (cmd.Args.length === 0) {
			t.errorf("empty command", new (go$sliceType(go$emptyInterface))([]));
		}
		return cmd;
	};
	Tree.prototype.command = function() { return this.go$val.command(); };
 0Treecommand0Ç0#text/template/parsepeekNonSpace0text/template/parseappend0text/template/parseitem0text/template/parseTree0!text/template/parse
newCommand0text/template/parseoperand0text/template/parsenext0text/template/parseerrorf0text/template/parsebackup0Çñ ÇÑ	Tree.Ptr.prototype.operand = function() {
		var t, node, chain, _ref;
		t = this;
		node = t.term();
		if (go$interfaceIsEqual(node, null)) {
			return null;
		}
		if (t.peek().typ === 7) {
			chain = newChain(t.peek().pos, node);
			while (t.peek().typ === 7) {
				chain.Add(t.next().val);
			}
			_ref = node.Type();
			if (_ref === 8) {
				node = newField((new Pos(chain.Pos)).Position(), chain.String());
			} else if (_ref === 18) {
				node = newVariable((new Pos(chain.Pos)).Position(), chain.String());
			} else {
				node = chain;
			}
		}
		return node;
	};
	Tree.prototype.operand = function() { return this.go$val.operand(); };
 0Treeoperand0Åˆ0text/template/parseTree0text/template/parseterm0text/template/parsepeek0text/template/parsenewChain0text/template/parsenext0text/template/parsenewField0text/template/parsePos0"text/template/parsenewVariable0Ç	û ÇK	Tree.Ptr.prototype.term = function() {
		var t, _struct, token, _ref, _tuple, number, err, pipe, token$1, _struct$1, _tuple$1, s, err$1;
		t = this;
		token = (_struct = t.nextNonSpace(), new item.Ptr(_struct.typ, _struct.pos, _struct.val));
		_ref = token.typ;
		if (_ref === 0) {
			t.errorf("%s", new (go$sliceType(go$emptyInterface))([new Go$String(token.val)]));
		} else if (_ref === 8) {
			if (!t.hasFunction(token.val)) {
				t.errorf("function %q not defined", new (go$sliceType(go$emptyInterface))([new Go$String(token.val)]));
			}
			return NewIdentifier(token.val).SetPos(token.pos);
		} else if (_ref === 21) {
			return newDot(token.pos);
		} else if (_ref === 26) {
			return newNil(token.pos);
		} else if (_ref === 19) {
			return t.useVar(token.pos, token.val);
		} else if (_ref === 7) {
			return newField(token.pos, token.val);
		} else if (_ref === 1) {
			return newBool(token.pos, token.val === "true");
		} else if (_ref === 3 || _ref === 4 || _ref === 11) {
			_tuple = newNumber(token.pos, token.val, token.typ), number = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				t.error(err);
			}
			return number;
		} else if (_ref === 10) {
			pipe = t.pipeline("parenthesized pipeline");
			if (token$1 = (_struct$1 = t.next(), new item.Ptr(_struct$1.typ, _struct$1.pos, _struct$1.val)), !((token$1.typ === 15))) {
				t.errorf("unclosed right paren: unexpected %s", new (go$sliceType(go$emptyInterface))([new token$1.constructor.Struct(token$1)]));
			}
			return pipe;
		} else if (_ref === 17 || _ref === 13) {
			_tuple$1 = strconv.Unquote(token.val), s = _tuple$1[0], err$1 = _tuple$1[1];
			if (!(go$interfaceIsEqual(err$1, null))) {
				t.error(err$1);
			}
			return newString(token.pos, token.val, s);
		}
		t.backup();
		return null;
	};
	Tree.prototype.term = function() { return this.go$val.term(); };
 0Treeterm0Ç90$text/template/parseNewIdentifier0 text/template/parse	newString0text/template/parsebackup0#text/template/parsenextNonSpace0text/template/parsenewBool0 text/template/parse	newNumber0strconvUnquote0text/template/parseTree0"text/template/parsehasFunction0text/template/parsenewField0text/template/parsenext0text/template/parseitem0text/template/parseerrorf0text/template/parsenewDot0text/template/parsenewNil0text/template/parseuseVar0text/template/parseerror0text/template/parsepipeline0Ç¡ ÇÖ	Tree.Ptr.prototype.hasFunction = function(name) {
		var t, _ref, _i, _slice, _index, funcMap, _entry;
		t = this;
		_ref = t.funcs;
		_i = 0;
		while (_i < _ref.length) {
			funcMap = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (funcMap === false) {
				_i++;
				continue;
			}
			if (!(go$interfaceIsEqual((_entry = funcMap[name], _entry !== undefined ? _entry.v : null), null))) {
				return true;
			}
			_i++;
		}
		return false;
	};
	Tree.prototype.hasFunction = function(name) { return this.go$val.hasFunction(name); };
 0TreehasFunction00text/template/parseTree0ÅÏ Åµ	Tree.Ptr.prototype.popVars = function(n) {
		var t;
		t = this;
		t.vars = go$subslice(t.vars, 0, n);
	};
	Tree.prototype.popVars = function(n) { return this.go$val.popVars(n); };
 0TreepopVars00text/template/parseTree0Çe ÇÎ	Tree.Ptr.prototype.useVar = function(pos, name) {
		var t, v, _ref, _i, _slice, _index, varName, _slice$1, _index$1, _slice$2, _index$2;
		t = this;
		v = newVariable(pos, name);
		_ref = t.vars;
		_i = 0;
		while (_i < _ref.length) {
			varName = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (varName === (_slice$1 = v.Ident, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))) {
				return v;
			}
			_i++;
		}
		t.errorf("undefined variable %q", new (go$sliceType(go$emptyInterface))([new Go$String((_slice$2 = v.Ident, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")))]));
		return null;
	};
	Tree.prototype.useVar = function(pos, name) { return this.go$val.useVar(pos, name); };
 0TreeuseVar0`0text/template/parseTree0"text/template/parsenewVariable0text/template/parseerrorf0key  0key0 0 
textFormat  0
textFormat0 0Ç  ÇÁ		var _map, _key;
		key = (_map = new Go$Map(), _key = ".", _map[_key] = { k: _key, v: 21 }, _key = "define", _map[_key] = { k: _key, v: 22 }, _key = "else", _map[_key] = { k: _key, v: 23 }, _key = "end", _map[_key] = { k: _key, v: 24 }, _key = "if", _map[_key] = { k: _key, v: 25 }, _key = "range", _map[_key] = { k: _key, v: 27 }, _key = "nil", _map[_key] = { k: _key, v: 26 }, _key = "template", _map[_key] = { k: _key, v: 28 }, _key = "with", _map[_key] = { k: _key, v: 29 }, _map);
0key00text/template/parsekey0N  		textFormat = "%s";
0
textFormat0#0!text/template/parse
textFormat0
   0 0 0
   0 0 0 