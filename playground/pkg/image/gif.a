0Ç™v	image/gifÇ$package gif
import bufio "bufio"
import lzw "compress/lzw"
import errors "errors"
import fmt "fmt"
import image "image"
import color "image/color"
import io "io"
import palette "image/color/palette"
import draw "image/draw"
func @"".Decode(@"".r @"io".Reader) (? @"image".Image, ? error)
func @"".DecodeAll(@"".r @"io".Reader) (? *@"".GIF, ? error)
func @"".DecodeConfig(@"".r @"io".Reader) (? @"image".Config, ? error)
func @"".Encode(@"".w @"io".Writer, @"".m @"image".Image, @"".o *@"".Options) (? error)
func @"".EncodeAll(@"".w @"io".Writer, @"".g *@"".GIF) (? error)
type @"".GIF struct { @"".Image []*@"image".Paletted; @"".Delay []int; @"".LoopCount int }
type @"".Options struct { @"".NumColors int; @"".Quantizer @"image/draw".Quantizer; @"".Drawer @"image/draw".Drawer }
type @"".blockReader struct { @"".r @"".reader; @"".slice []byte; @"".err error; @"".tmp [256]byte }
func (? *@"".blockReader) @"".Read(@"".p []byte) (? int, ? error)
type @"".blockWriter struct { @"".e *@"".encoder }
func (? @"".blockWriter) @"".Write(@"".data []byte) (? int, ? error)
func (? *@"".blockWriter) @"".Write(@"".data []byte) (? int, ? error)
type @"".decoder struct { @"".r @"".reader; @"".vers string; @"".width int; @"".height int; @"".flags byte; @"".headerFields byte; @"".backgroundIndex byte; @"".loopCount int; @"".delayTime int; @"".aspect byte; @"".imageFields byte; @"".transparentIndex byte; @"".pixelSize uint; @"".globalColorMap @"image/color".Palette; @"".delay []int; @"".image []*@"image".Paletted; @"".tmp [1024]byte }
func (? *@"".decoder) @"".decode(@"".r @"io".Reader, @"".configOnly bool) (? error)
func (? *@"".decoder) @"".newImageFromDescriptor() (? *@"image".Paletted, ? error)
func (? *@"".decoder) @"".readBlock() (? int, ? error)
func (? *@"".decoder) @"".readColorMap() (? @"image/color".Palette, ? error)
func (? *@"".decoder) @"".readExtension() (? error)
func (? *@"".decoder) @"".readGraphicControl() (? error)
func (? *@"".decoder) @"".readHeaderAndScreenDescriptor() (? error)
func (? *@"".decoder) @"".setTransparency(@"".colorMap @"image/color".Palette) ()
type @"".encoder struct { @"".w @"".writer; @"".err error; @"".g *@"".GIF; @"".buf [1024]byte }
func (? *@"".encoder) @"".flush() ()
func (? *@"".encoder) @"".write(@"".p []byte) ()
func (? *@"".encoder) @"".writeByte(@"".b byte) ()
func (? *@"".encoder) @"".writeColorTable(@"".p @"image/color".Palette, @"".size int) ()
func (? *@"".encoder) @"".writeHeader() ()
func (? *@"".encoder) @"".writeImageBlock(@"".pm *@"image".Paletted, @"".delay int) ()
type @"".interlaceScan struct { @"".skip int; @"".start int }
type @"".reader interface { @"io".Read(@"".p []byte) (@"".n int, @"".err error); @"io".ReadByte() (@"".c byte, @"".err error) }
type @"".writer interface { @"".Flush() (? error); @"io".Write(@"".p []byte) (@"".n int, @"".err error); @"io".WriteByte(@"".c byte) (? error) }
type @"io".Reader interface { @"io".Read(@"".p []byte) (@"".n int, @"".err error) }
type @"image".Image interface { @"image".At(@"image".x int, @"image".y int) (? @"image/color".Color); @"image".Bounds() (? @"image".Rectangle); @"image".ColorModel() (? @"image/color".Model) }
type @"image".Config struct { @"image".ColorModel @"image/color".Model; @"image".Width int; @"image".Height int }
type @"io".Writer interface { @"io".Write(@"".p []byte) (@"".n int, @"".err error) }
type @"image".Paletted struct { @"image".Pix []uint8; @"image".Stride int; @"image".Rect @"image".Rectangle; @"image".Palette @"image/color".Palette }
func (? *@"image".Paletted) @"image".At(@"image".x int, @"image".y int) (? @"image/color".Color)
func (? *@"image".Paletted) @"image".Bounds() (? @"image".Rectangle)
func (? *@"image".Paletted) @"image".ColorIndexAt(@"image".x int, @"image".y int) (? uint8)
func (? *@"image".Paletted) @"image".ColorModel() (? @"image/color".Model)
func (? *@"image".Paletted) @"image".Opaque() (? bool)
func (? *@"image".Paletted) @"image".PixOffset(@"image".x int, @"image".y int) (? int)
func (? *@"image".Paletted) @"image".Set(@"image".x int, @"image".y int, @"image".c @"image/color".Color) ()
func (? *@"image".Paletted) @"image".SetColorIndex(@"image".x int, @"image".y int, @"image".index uint8) ()
func (? *@"image".Paletted) @"image".SubImage(@"image".r @"image".Rectangle) (? @"image".Image)
type @"image/draw".Quantizer interface { @"image/draw".Quantize(@"image/draw".p @"image/color".Palette, @"image/draw".m @"image".Image) (? @"image/color".Palette) }
type @"image/draw".Drawer interface { @"image/draw".Draw(@"image/draw".dst @"image/draw".Image, @"image/draw".r @"image".Rectangle, @"image/draw".src @"image".Image, @"image/draw".sp @"image".Point) () }
type @"image/color".Palette []@"image/color".Color
func (? @"image/color".Palette) @"image/color".Convert(@"image/color".c @"image/color".Color) (? @"image/color".Color)
func (? @"image/color".Palette) @"image/color".Index(@"image/color".c @"image/color".Color) (? int)
func (? *@"image/color".Palette) @"image/color".Convert(@"image/color".c @"image/color".Color) (? @"image/color".Color)
func (? *@"image/color".Palette) @"image/color".Index(@"image/color".c @"image/color".Color) (? int)
type @"image/color".Color interface { @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32) }
type @"image".Rectangle struct { @"image".Min @"image".Point; @"image".Max @"image".Point }
func (? @"image".Rectangle) @"image".Add(@"image".p @"image".Point) (? @"image".Rectangle)
func (? @"image".Rectangle) @"image".Canon() (? @"image".Rectangle)
func (? @"image".Rectangle) @"image".Dx() (? int)
func (? @"image".Rectangle) @"image".Dy() (? int)
func (? @"image".Rectangle) @"image".Empty() (? bool)
func (? @"image".Rectangle) @"image".Eq(@"image".s @"image".Rectangle) (? bool)
func (? @"image".Rectangle) @"image".In(@"image".s @"image".Rectangle) (? bool)
func (? @"image".Rectangle) @"image".Inset(@"image".n int) (? @"image".Rectangle)
func (? @"image".Rectangle) @"image".Intersect(@"image".s @"image".Rectangle) (? @"image".Rectangle)
func (? @"image".Rectangle) @"image".Overlaps(@"image".s @"image".Rectangle) (? bool)
func (? @"image".Rectangle) @"image".Size() (? @"image".Point)
func (? @"image".Rectangle) @"image".String() (? string)
func (? @"image".Rectangle) @"image".Sub(@"image".p @"image".Point) (? @"image".Rectangle)
func (? @"image".Rectangle) @"image".Union(@"image".s @"image".Rectangle) (? @"image".Rectangle)
func (? *@"image".Rectangle) @"image".Add(@"image".p @"image".Point) (? @"image".Rectangle)
func (? *@"image".Rectangle) @"image".Canon() (? @"image".Rectangle)
func (? *@"image".Rectangle) @"image".Dx() (? int)
func (? *@"image".Rectangle) @"image".Dy() (? int)
func (? *@"image".Rectangle) @"image".Empty() (? bool)
func (? *@"image".Rectangle) @"image".Eq(@"image".s @"image".Rectangle) (? bool)
func (? *@"image".Rectangle) @"image".In(@"image".s @"image".Rectangle) (? bool)
func (? *@"image".Rectangle) @"image".Inset(@"image".n int) (? @"image".Rectangle)
func (? *@"image".Rectangle) @"image".Intersect(@"image".s @"image".Rectangle) (? @"image".Rectangle)
func (? *@"image".Rectangle) @"image".Overlaps(@"image".s @"image".Rectangle) (? bool)
func (? *@"image".Rectangle) @"image".Size() (? @"image".Point)
func (? *@"image".Rectangle) @"image".String() (? string)
func (? *@"image".Rectangle) @"image".Sub(@"image".p @"image".Point) (? @"image".Rectangle)
func (? *@"image".Rectangle) @"image".Union(@"image".s @"image".Rectangle) (? @"image".Rectangle)
type @"image/color".Model interface { @"image/color".Convert(@"image/color".c @"image/color".Color) (? @"image/color".Color) }
type @"image/draw".Image interface { @"image".At(@"image".x int, @"image".y int) (? @"image/color".Color); @"image".Bounds() (? @"image".Rectangle); @"image".ColorModel() (? @"image/color".Model); @"image/draw".Set(@"image/draw".x int, @"image/draw".y int, @"image/draw".c @"image/color".Color) () }
type @"image".Point struct { @"image".X int; @"image".Y int }
func (? @"image".Point) @"image".Add(@"image".q @"image".Point) (? @"image".Point)
func (? @"image".Point) @"image".Div(@"image".k int) (? @"image".Point)
func (? @"image".Point) @"image".Eq(@"image".q @"image".Point) (? bool)
func (? @"image".Point) @"image".In(@"image".r @"image".Rectangle) (? bool)
func (? @"image".Point) @"image".Mod(@"image".r @"image".Rectangle) (? @"image".Point)
func (? @"image".Point) @"image".Mul(@"image".k int) (? @"image".Point)
func (? @"image".Point) @"image".String() (? string)
func (? @"image".Point) @"image".Sub(@"image".q @"image".Point) (? @"image".Point)
func (? *@"image".Point) @"image".Add(@"image".q @"image".Point) (? @"image".Point)
func (? *@"image".Point) @"image".Div(@"image".k int) (? @"image".Point)
func (? *@"image".Point) @"image".Eq(@"image".q @"image".Point) (? bool)
func (? *@"image".Point) @"image".In(@"image".r @"image".Rectangle) (? bool)
func (? *@"image".Point) @"image".Mod(@"image".r @"image".Rectangle) (? @"image".Point)
func (? *@"image".Point) @"image".Mul(@"image".k int) (? @"image".Point)
func (? *@"image".Point) @"image".String() (? string)
func (? *@"image".Point) @"image".Sub(@"image".q @"image".Point) (? @"image".Point)
$$
0ÅÀruntimeerrorssync/atomicsynciounicodeunicode/utf8bytesbufiomathsyscalltimeosstrconvreflectfmtcompress/lzwimage/colorimageimage/color/palette
image/draw	image/gif0Åß0bufiobufio0compress/lzwlzw0errorserrors0
fmtfmt0imageimage0image/colorcolor0ioio0image/color/palettepalette0
image/drawdraw0ÇÑÁ0Ç readera	reader = go$pkg.reader = go$newType(0, "Interface", "gif.reader", "reader", "image/gif", null);
Åß		reader.init([["Read", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))], ["ReadByte", "", (go$funcType([], [Go$Uint8, go$error], false))]]);
0Ç decoderÇπ	decoder = go$pkg.decoder = go$newType(0, "Struct", "gif.decoder", "decoder", "image/gif", function(r_, vers_, width_, height_, flags_, headerFields_, backgroundIndex_, loopCount_, delayTime_, aspect_, imageFields_, transparentIndex_, pixelSize_, globalColorMap_, delay_, image_, tmp_) {
		this.go$val = this;
		this.r = r_ !== undefined ? r_ : null;
		this.vers = vers_ !== undefined ? vers_ : "";
		this.width = width_ !== undefined ? width_ : 0;
		this.height = height_ !== undefined ? height_ : 0;
		this.flags = flags_ !== undefined ? flags_ : 0;
		this.headerFields = headerFields_ !== undefined ? headerFields_ : 0;
		this.backgroundIndex = backgroundIndex_ !== undefined ? backgroundIndex_ : 0;
		this.loopCount = loopCount_ !== undefined ? loopCount_ : 0;
		this.delayTime = delayTime_ !== undefined ? delayTime_ : 0;
		this.aspect = aspect_ !== undefined ? aspect_ : 0;
		this.imageFields = imageFields_ !== undefined ? imageFields_ : 0;
		this.transparentIndex = transparentIndex_ !== undefined ? transparentIndex_ : 0;
		this.pixelSize = pixelSize_ !== undefined ? pixelSize_ : 0;
		this.globalColorMap = globalColorMap_ !== undefined ? globalColorMap_ : color.Palette.nil;
		this.delay = delay_ !== undefined ? delay_ : (go$sliceType(Go$Int)).nil;
		this.image = image_ !== undefined ? image_ : (go$sliceType((go$ptrType(image.Paletted)))).nil;
		this.tmp = tmp_ !== undefined ? tmp_ : go$makeNativeArray("Uint8", 1024, function() { return 0; });
	});
ÇI		decoder.init([["r", "image/gif", reader, ""], ["vers", "image/gif", Go$String, ""], ["width", "image/gif", Go$Int, ""], ["height", "image/gif", Go$Int, ""], ["flags", "image/gif", Go$Uint8, ""], ["headerFields", "image/gif", Go$Uint8, ""], ["backgroundIndex", "image/gif", Go$Uint8, ""], ["loopCount", "image/gif", Go$Int, ""], ["delayTime", "image/gif", Go$Int, ""], ["aspect", "image/gif", Go$Uint8, ""], ["imageFields", "image/gif", Go$Uint8, ""], ["transparentIndex", "image/gif", Go$Uint8, ""], ["pixelSize", "image/gif", Go$Uint, ""], ["globalColorMap", "image/gif", color.Palette, ""], ["delay", "image/gif", (go$sliceType(Go$Int)), ""], ["image", "image/gif", (go$sliceType((go$ptrType(image.Paletted)))), ""], ["tmp", "image/gif", (go$arrayType(Go$Uint8, 1024)), ""]]);
		(go$ptrType(decoder)).methods = [["decode", "image/gif", [io.Reader, Go$Bool], [go$error], false], ["newImageFromDescriptor", "image/gif", [], [(go$ptrType(image.Paletted)), go$error], false], ["readBlock", "image/gif", [], [Go$Int, go$error], false], ["readColorMap", "image/gif", [], [color.Palette, go$error], false], ["readExtension", "image/gif", [], [go$error], false], ["readGraphicControl", "image/gif", [], [go$error], false], ["readHeaderAndScreenDescriptor", "image/gif", [], [go$error], false], ["setTransparency", "image/gif", [color.Palette], [], false]];
0Ç  blockReaderÇ≥	blockReader = go$pkg.blockReader = go$newType(0, "Struct", "gif.blockReader", "blockReader", "image/gif", function(r_, slice_, err_, tmp_) {
		this.go$val = this;
		this.r = r_ !== undefined ? r_ : null;
		this.slice = slice_ !== undefined ? slice_ : (go$sliceType(Go$Uint8)).nil;
		this.err = err_ !== undefined ? err_ : null;
		this.tmp = tmp_ !== undefined ? tmp_ : go$makeNativeArray("Uint8", 256, function() { return 0; });
	});
Ç6		blockReader.init([["r", "image/gif", reader, ""], ["slice", "image/gif", (go$sliceType(Go$Uint8)), ""], ["err", "image/gif", go$error, ""], ["tmp", "image/gif", (go$arrayType(Go$Uint8, 256)), ""]]);
		(go$ptrType(blockReader)).methods = [["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
0Ç interlaceScanÇ		interlaceScan = go$pkg.interlaceScan = go$newType(0, "Struct", "gif.interlaceScan", "interlaceScan", "image/gif", function(skip_, start_) {
		this.go$val = this;
		this.skip = skip_ !== undefined ? skip_ : 0;
		this.start = start_ !== undefined ? start_ : 0;
	});
_		interlaceScan.init([["skip", "image/gif", Go$Int, ""], ["start", "image/gif", Go$Int, ""]]);
0Ç GIFÇw	GIF = go$pkg.GIF = go$newType(0, "Struct", "gif.GIF", "GIF", "image/gif", function(Image_, Delay_, LoopCount_) {
		this.go$val = this;
		this.Image = Image_ !== undefined ? Image_ : (go$sliceType((go$ptrType(image.Paletted)))).nil;
		this.Delay = Delay_ !== undefined ? Delay_ : (go$sliceType(Go$Int)).nil;
		this.LoopCount = LoopCount_ !== undefined ? LoopCount_ : 0;
	});
Åô		GIF.init([["Image", "", (go$sliceType((go$ptrType(image.Paletted)))), ""], ["Delay", "", (go$sliceType(Go$Int)), ""], ["LoopCount", "", Go$Int, ""]]);
0ÇL writera	writer = go$pkg.writer = go$newType(0, "Interface", "gif.writer", "writer", "image/gif", null);
Å‹		writer.init([["Flush", "", (go$funcType([], [go$error], false))], ["Write", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))], ["WriteByte", "", (go$funcType([Go$Uint8], [go$error], false))]]);
0Ç‡ encoderÇç	encoder = go$pkg.encoder = go$newType(0, "Struct", "gif.encoder", "encoder", "image/gif", function(w_, err_, g_, buf_) {
		this.go$val = this;
		this.w = w_ !== undefined ? w_ : null;
		this.err = err_ !== undefined ? err_ : null;
		this.g = g_ !== undefined ? g_ : (go$ptrType(GIF)).nil;
		this.buf = buf_ !== undefined ? buf_ : go$makeNativeArray("Uint8", 1024, function() { return 0; });
	});
Ç@		encoder.init([["w", "image/gif", writer, ""], ["err", "image/gif", go$error, ""], ["g", "image/gif", (go$ptrType(GIF)), ""], ["buf", "image/gif", (go$arrayType(Go$Uint8, 1024)), ""]]);
		(go$ptrType(encoder)).methods = [["flush", "image/gif", [], [], false], ["write", "image/gif", [(go$sliceType(Go$Uint8))], [], false], ["writeByte", "image/gif", [Go$Uint8], [], false], ["writeColorTable", "image/gif", [color.Palette, Go$Int], [], false], ["writeHeader", "image/gif", [], [], false], ["writeImageBlock", "image/gif", [(go$ptrType(image.Paletted)), Go$Int], [], false]];
0Ç¸ blockWriterÅ”	blockWriter = go$pkg.blockWriter = go$newType(0, "Struct", "gif.blockWriter", "blockWriter", "image/gif", function(e_) {
		this.go$val = this;
		this.e = e_ !== undefined ? e_ : (go$ptrType(encoder)).nil;
	});
Ç		blockWriter.init([["e", "image/gif", (go$ptrType(encoder)), ""]]);
		blockWriter.methods = [["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
		(go$ptrType(blockWriter)).methods = [["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
0Ç„ OptionsÇY	Options = go$pkg.Options = go$newType(0, "Struct", "gif.Options", "Options", "image/gif", function(NumColors_, Quantizer_, Drawer_) {
		this.go$val = this;
		this.NumColors = NumColors_ !== undefined ? NumColors_ : 0;
		this.Quantizer = Quantizer_ !== undefined ? Quantizer_ : null;
		this.Drawer = Drawer_ !== undefined ? Drawer_ : null;
	});
y		Options.init([["NumColors", "", Go$Int, ""], ["Quantizer", "", draw.Quantizer, ""], ["Drawer", "", draw.Drawer, ""]]);
0Çj  Ç`	blockReader.Ptr.prototype.Read = function(p) {
		var b, blockLen, _tuple, _tuple$1, n;
		b = this;
		if (!(go$interfaceIsEqual(b.err, null))) {
			return [0, b.err];
		}
		if (p.length === 0) {
			return [0, null];
		}
		if (b.slice.length === 0) {
			blockLen = 0;
			_tuple = b.r.ReadByte(), blockLen = _tuple[0], b.err = _tuple[1];
			if (!(go$interfaceIsEqual(b.err, null))) {
				return [0, b.err];
			}
			if (blockLen === 0) {
				b.err = io.EOF;
				return [0, b.err];
			}
			b.slice = go$subslice(new (go$sliceType(Go$Uint8))(b.tmp), 0, blockLen);
			if (_tuple$1 = io.ReadFull(b.r, b.slice), b.err = _tuple$1[1], !(go$interfaceIsEqual(b.err, null))) {
				return [0, b.err];
			}
		}
		n = go$copySlice(p, b.slice);
		b.slice = go$subslice(b.slice, n);
		return [n, null];
	};
	blockReader.prototype.Read = function(p) { return this.go$val.Read(p); };
 0Ç  Ç	decoder.Ptr.prototype.decode = function(r, configOnly) {
		var d, ok, _tuple, rr, err, _tuple$1, _tuple$2, c, err$1, _ref, _tuple$3, m, err$2, _tuple$4, _tuple$5, litWidth, br, lzwr, _tuple$6, n, err$3, _tuple$7, n$1, err$4, _tuple$8, _ref$1, _i, _slice, _index, pixel;
		var go$deferred = [];
		try {
			d = this;
			if (_tuple = (r !== null && reader.implementedBy.indexOf(r.constructor) !== -1 ? [r, true] : [null, false]), rr = _tuple[0], ok = _tuple[1], ok) {
				d.r = rr;
			} else {
				d.r = bufio.NewReader(r);
			}
			err = d.readHeaderAndScreenDescriptor();
			if (!(go$interfaceIsEqual(err, null))) {
				return err;
			}
			if (configOnly) {
				return null;
			}
			if (!((((d.headerFields & 128) >>> 0) === 0))) {
				if (_tuple$1 = d.readColorMap(), d.globalColorMap = _tuple$1[0], err = _tuple$1[1], !(go$interfaceIsEqual(err, null))) {
					return err;
				}
			}
			while (true) {
				_tuple$2 = d.r.ReadByte(), c = _tuple$2[0], err$1 = _tuple$2[1];
				if (!(go$interfaceIsEqual(err$1, null))) {
					return err$1;
				}
				_ref = c;
				if (_ref === 33) {
					if (err$1 = d.readExtension(), !(go$interfaceIsEqual(err$1, null))) {
						return err$1;
					}
				} else if (_ref === 44) {
					_tuple$3 = d.newImageFromDescriptor(), m = _tuple$3[0], err$2 = _tuple$3[1];
					if (!(go$interfaceIsEqual(err$2, null))) {
						return err$2;
					}
					if (!((((d.imageFields & 128) >>> 0) === 0))) {
						_tuple$4 = d.readColorMap(), m.Palette = _tuple$4[0], err$2 = _tuple$4[1];
						if (!(go$interfaceIsEqual(err$2, null))) {
							return err$2;
						}
					} else {
						m.Palette = d.globalColorMap;
					}
					_tuple$5 = d.r.ReadByte(), litWidth = _tuple$5[0], err$2 = _tuple$5[1];
					if (!(go$interfaceIsEqual(err$2, null))) {
						return err$2;
					}
					if (litWidth < 2 || litWidth > 8) {
						return fmt.Errorf("gif: pixel size in decode out of range: %d", new (go$sliceType(go$emptyInterface))([new Go$Uint8(litWidth)]));
					}
					br = new blockReader.Ptr(d.r, (go$sliceType(Go$Uint8)).nil, null, go$makeNativeArray("Uint8", 256, function() { return 0; }));
					lzwr = lzw.NewReader(br, 0, (litWidth >> 0));
					go$deferred.push({ recv: lzwr, method: "Close", args: [] });
					if (_tuple$6 = io.ReadFull(lzwr, m.Pix), err$2 = _tuple$6[1], !(go$interfaceIsEqual(err$2, null))) {
						if (!(go$interfaceIsEqual(err$2, io.ErrUnexpectedEOF))) {
							return err$2;
						}
						return errNotEnough;
					}
					if (_tuple$7 = lzwr.Read(go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, 1)), n = _tuple$7[0], err$3 = _tuple$7[1], !((n === 0)) || !(go$interfaceIsEqual(err$3, io.EOF))) {
						if (!(go$interfaceIsEqual(err$3, null))) {
							return err$3;
						}
						return errTooMuch;
					}
					if (_tuple$8 = br.Read(go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, 1)), n$1 = _tuple$8[0], err$4 = _tuple$8[1], !((n$1 === 0)) || !(go$interfaceIsEqual(err$4, io.EOF))) {
						if (!(go$interfaceIsEqual(err$4, null))) {
							return err$4;
						}
						return errTooMuch;
					}
					if (m.Palette.length < 256) {
						_ref$1 = m.Pix;
						_i = 0;
						while (_i < _ref$1.length) {
							pixel = (_slice = _ref$1, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
							if ((pixel >> 0) >= m.Palette.length) {
								return errBadPixel;
							}
							_i++;
						}
					}
					if (!((((d.imageFields & 64) >>> 0) === 0))) {
						uninterlace(m);
					}
					d.image = go$append(d.image, m);
					d.delay = go$append(d.delay, d.delayTime);
					d.delayTime = 0;
				} else if (_ref === 59) {
					if (d.image.length === 0) {
						return io.ErrUnexpectedEOF;
					}
					return null;
				} else {
					return fmt.Errorf("gif: unknown block type: 0x%.2x", new (go$sliceType(go$emptyInterface))([new Go$Uint8(c)]));
				}
			}
		} catch(go$err) {
			go$pushErr(go$err);
			return null;
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	decoder.prototype.decode = function(r, configOnly) { return this.go$val.decode(r, configOnly); };
 0Ç÷  ÇÃ	decoder.Ptr.prototype.readHeaderAndScreenDescriptor = function() {
		var d, _tuple, err;
		d = this;
		_tuple = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, 13)), err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		d.vers = go$bytesToString(go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, 6));
		if (!(d.vers === "GIF87a") && !(d.vers === "GIF89a")) {
			return fmt.Errorf("gif: can't recognize format %s", new (go$sliceType(go$emptyInterface))([new Go$String(d.vers)]));
		}
		d.width = (d.tmp[6] >> 0) + ((d.tmp[7] >> 0) << 8 >> 0) >> 0;
		d.height = (d.tmp[8] >> 0) + ((d.tmp[9] >> 0) << 8 >> 0) >> 0;
		d.headerFields = d.tmp[10];
		d.backgroundIndex = d.tmp[11];
		d.aspect = d.tmp[12];
		d.loopCount = -1;
		d.pixelSize = (((d.headerFields & 7) >>> 0) >>> 0) + 1 >>> 0;
		return null;
	};
	decoder.prototype.readHeaderAndScreenDescriptor = function() { return this.go$val.readHeaderAndScreenDescriptor(); };
 0Ç  Ç	decoder.Ptr.prototype.readColorMap = function() {
		var d, y, numColors, y$1, x, numValues, _tuple, err, colorMap, j, _ref, _i, i, x$1, _slice, _index;
		d = this;
		if (d.pixelSize > 8) {
			return [color.Palette.nil, fmt.Errorf("gif: can't handle %d bits per pixel", new (go$sliceType(go$emptyInterface))([new Go$Uint(d.pixelSize)]))];
		}
		numColors = (y = d.pixelSize, y < 32 ? (1 << y) : 0) >> 0;
		if (!((((d.imageFields & 128) >>> 0) === 0))) {
			numColors = (y$1 = (((((d.imageFields & 7) >>> 0)) + 1 << 24 >>> 24)), y$1 < 32 ? (1 << y$1) : 0) >> 0;
		}
		numValues = (x = 3, (((x >>> 16 << 16) * numColors >> 0) + (x << 16 >>> 16) * numColors) >> 0);
		_tuple = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, numValues)), err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [color.Palette.nil, fmt.Errorf("gif: short read on color map: %s", new (go$sliceType(go$emptyInterface))([err]))];
		}
		colorMap = color.Palette.make(numColors, 0, function() { return null; });
		j = 0;
		_ref = colorMap;
		_i = 0;
		while (_i < _ref.length) {
			i = _i;
			_slice = colorMap, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = (x$1 = new color.RGBA.Ptr(d.tmp[(j + 0 >> 0)], d.tmp[(j + 1 >> 0)], d.tmp[(j + 2 >> 0)], 255), new x$1.constructor.Struct(x$1))) : go$throwRuntimeError("index out of range");
			j = j + 3 >> 0;
			_i++;
		}
		return [colorMap, null];
	};
	decoder.prototype.readColorMap = function() { return this.go$val.readColorMap(); };
 0Ç}  Çs	decoder.Ptr.prototype.readExtension = function() {
		var d, _tuple, extension, err, size, _ref, _tuple$1, b, err$1, err$2, _tuple$2, _tuple$3, n, err$3, _tuple$4, n$1, err$4;
		d = this;
		_tuple = d.r.ReadByte(), extension = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		size = 0;
		_ref = extension;
		if (_ref === 1) {
			size = 13;
		} else if (_ref === 249) {
			return d.readGraphicControl();
		} else if (_ref === 254) {
		} else if (_ref === 255) {
			_tuple$1 = d.r.ReadByte(), b = _tuple$1[0], err$1 = _tuple$1[1];
			if (!(go$interfaceIsEqual(err$1, null))) {
				return err$1;
			}
			size = (b >> 0);
		} else {
			return fmt.Errorf("gif: unknown extension 0x%.2x", new (go$sliceType(go$emptyInterface))([new Go$Uint8(extension)]));
		}
		if (size > 0) {
			if (_tuple$2 = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, size)), err$2 = _tuple$2[1], !(go$interfaceIsEqual(err$2, null))) {
				return err$2;
			}
		}
		if ((extension === 255) && go$bytesToString(go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, size)) === "NETSCAPE2.0") {
			_tuple$3 = d.readBlock(), n = _tuple$3[0], err$3 = _tuple$3[1];
			if ((n === 0) || !(go$interfaceIsEqual(err$3, null))) {
				return err$3;
			}
			if ((n === 3) && (d.tmp[0] === 1)) {
				d.loopCount = (d.tmp[1] >> 0) | ((d.tmp[2] >> 0) << 8 >> 0);
			}
		}
		while (true) {
			_tuple$4 = d.readBlock(), n$1 = _tuple$4[0], err$4 = _tuple$4[1];
			if ((n$1 === 0) || !(go$interfaceIsEqual(err$4, null))) {
				return err$4;
			}
		}
	};
	decoder.prototype.readExtension = function() { return this.go$val.readExtension(); };
 0Ç§  Çö	decoder.Ptr.prototype.readGraphicControl = function() {
		var d, err, _tuple;
		d = this;
		if (_tuple = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, 6)), err = _tuple[1], !(go$interfaceIsEqual(err, null))) {
			return fmt.Errorf("gif: can't read graphic control: %s", new (go$sliceType(go$emptyInterface))([err]));
		}
		d.flags = d.tmp[1];
		d.delayTime = (d.tmp[2] >> 0) | ((d.tmp[3] >> 0) << 8 >> 0);
		if (!((((d.flags & 1) >>> 0) === 0))) {
			d.transparentIndex = d.tmp[4];
			d.setTransparency(d.globalColorMap);
		}
		return null;
	};
	decoder.prototype.readGraphicControl = function() { return this.go$val.readGraphicControl(); };
 0Ç  Ç	decoder.Ptr.prototype.setTransparency = function(colorMap) {
		var d, x, _slice, _index;
		d = this;
		if ((d.transparentIndex >> 0) < colorMap.length) {
			_slice = colorMap, _index = d.transparentIndex, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = (x = new color.RGBA.Ptr(0, 0, 0, 0), new x.constructor.Struct(x))) : go$throwRuntimeError("index out of range");
		}
	};
	decoder.prototype.setTransparency = function(colorMap) { return this.go$val.setTransparency(colorMap); };
 0Ç®  Çû	decoder.Ptr.prototype.newImageFromDescriptor = function() {
		var d, err, _tuple, left, top, width, height, _struct, _struct$1, _struct$2, bounds, x, y, x$1, y$1, x$2, y$2, _struct$3, _struct$4, _struct$5, _struct$6, _struct$7, _struct$8;
		d = this;
		if (_tuple = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, 9)), err = _tuple[1], !(go$interfaceIsEqual(err, null))) {
			return [(go$ptrType(image.Paletted)).nil, fmt.Errorf("gif: can't read image descriptor: %s", new (go$sliceType(go$emptyInterface))([err]))];
		}
		left = (d.tmp[0] >> 0) + ((d.tmp[1] >> 0) << 8 >> 0) >> 0;
		top = (d.tmp[2] >> 0) + ((d.tmp[3] >> 0) << 8 >> 0) >> 0;
		width = (d.tmp[4] >> 0) + ((d.tmp[5] >> 0) << 8 >> 0) >> 0;
		height = (d.tmp[6] >> 0) + ((d.tmp[7] >> 0) << 8 >> 0) >> 0;
		d.imageFields = d.tmp[8];
		bounds = (_struct = image.Rect(left, top, left + width >> 0, top + height >> 0), new image.Rectangle.Ptr((_struct$1 = _struct.Min, new image.Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new image.Point.Ptr(_struct$2.X, _struct$2.Y))));
		if (!((x = bounds, y = bounds.Intersect((_struct$3 = image.Rect(0, 0, d.width, d.height), new image.Rectangle.Ptr((_struct$4 = _struct$3.Min, new image.Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new image.Point.Ptr(_struct$5.X, _struct$5.Y))))), (x$1 = x.Min, y$1 = y.Min, x$1.X === y$1.X && x$1.Y === y$1.Y) && (x$2 = x.Max, y$2 = y.Max, x$2.X === y$2.X && x$2.Y === y$2.Y)))) {
			return [(go$ptrType(image.Paletted)).nil, errors.New("gif: frame bounds larger than image bounds")];
		}
		return [image.NewPaletted((_struct$6 = bounds, new image.Rectangle.Ptr((_struct$7 = _struct$6.Min, new image.Point.Ptr(_struct$7.X, _struct$7.Y)), (_struct$8 = _struct$6.Max, new image.Point.Ptr(_struct$8.X, _struct$8.Y)))), color.Palette.nil), null];
	};
	decoder.prototype.newImageFromDescriptor = function() { return this.go$val.newImageFromDescriptor(); };
 0Çê  ÇÜ	decoder.Ptr.prototype.readBlock = function() {
		var d, _tuple, n, err;
		d = this;
		_tuple = d.r.ReadByte(), n = _tuple[0], err = _tuple[1];
		if ((n === 0) || !(go$interfaceIsEqual(err, null))) {
			return [0, err];
		}
		return io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, n));
	};
	decoder.prototype.readBlock = function() { return this.go$val.readBlock(); };
 0Çd uninterlaceÇO	uninterlace = function(m) {
		var nPix, dx, dy, offset, _ref, _i, _slice, _index, _struct, pass, x, nOffset, y, x$1;
		nPix = (go$sliceType(Go$Uint8)).nil;
		dx = m.Bounds().Dx();
		dy = m.Bounds().Dy();
		nPix = (go$sliceType(Go$Uint8)).make((((dx >>> 16 << 16) * dy >> 0) + (dx << 16 >>> 16) * dy) >> 0, 0, function() { return 0; });
		offset = 0;
		_ref = interlacing;
		_i = 0;
		while (_i < _ref.length) {
			pass = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new interlaceScan.Ptr(_struct.skip, _struct.start));
			nOffset = (x = pass.start, (((x >>> 16 << 16) * dx >> 0) + (x << 16 >>> 16) * dx) >> 0);
			y = pass.start;
			while (y < dy) {
				go$copySlice(go$subslice(nPix, nOffset, (nOffset + dx >> 0)), go$subslice(m.Pix, offset, (offset + dx >> 0)));
				offset = offset + (dx) >> 0;
				nOffset = nOffset + ((x$1 = pass.skip, (((dx >>> 16 << 16) * x$1 >> 0) + (dx << 16 >>> 16) * x$1) >> 0)) >> 0;
				y = y + (pass.skip) >> 0;
			}
			_i++;
		}
		m.Pix = nPix;
	};
 0ÇÅ DecodeÇq	Decode = go$pkg.Decode = function(r) {
		var d, err, _slice, _index;
		d = new decoder.Ptr();
		if (err = d.decode(r, false), !(go$interfaceIsEqual(err, null))) {
			return [null, err];
		}
		return [(_slice = d.image, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), null];
	};
 0Ç, 	DecodeAllÇ	DecodeAll = go$pkg.DecodeAll = function(r) {
		var d, err, gif;
		d = new decoder.Ptr();
		if (err = d.decode(r, false), !(go$interfaceIsEqual(err, null))) {
			return [(go$ptrType(GIF)).nil, err];
		}
		gif = new GIF.Ptr(d.image, d.delay, d.loopCount);
		return [gif, null];
	};
 0Ç< DecodeConfigÇ&	DecodeConfig = go$pkg.DecodeConfig = function(r) {
		var d, err;
		d = new decoder.Ptr();
		if (err = d.decode(r, true), !(go$interfaceIsEqual(err, null))) {
			return [new image.Config.Ptr(null, 0, 0), err];
		}
		return [new image.Config.Ptr(d.globalColorMap, d.width, d.height), null];
	};
 0Å… log2Åº	log2 = function(x) {
		var _ref, _i, v, i;
		_ref = log2Lookup;
		_i = 0;
		while (_i < 8) {
			v = _ref[_i];
			i = _i;
			if (x <= v) {
				return i;
			}
			_i++;
		}
		return -1;
	};
 0Ç‡ writeUint16ÇÀ	writeUint16 = function(b, u) {
		var _slice, _index, _slice$1, _index$1;
		_slice = b, _index = 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = (u << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$1 = b, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = ((u >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
	};
 0Ç6  Ç,	blockWriter.Ptr.prototype.Write = function(data) {
		var _struct, b, total, n, _tuple;
		b = (_struct = this, new blockWriter.Ptr(_struct.e));
		if (!(go$interfaceIsEqual(b.e.err, null))) {
			return [0, b.e.err];
		}
		if (data.length === 0) {
			return [0, null];
		}
		total = 0;
		while (total < data.length) {
			n = go$copySlice(go$subslice(new (go$sliceType(Go$Uint8))(b.e.buf), 1, 256), go$subslice(data, total));
			total = total + (n) >> 0;
			b.e.buf[0] = (n << 24 >>> 24);
			_tuple = b.e.w.Write(go$subslice(new (go$sliceType(Go$Uint8))(b.e.buf), 0, (n + 1 >> 0))), n = _tuple[0], b.e.err = _tuple[1];
			if (!(go$interfaceIsEqual(b.e.err, null))) {
				return [0, b.e.err];
			}
		}
		return [total, b.e.err];
	};
	blockWriter.prototype.Write = function(data) { return this.go$val.Write(data); };
 0ÅË  Åﬂ	encoder.Ptr.prototype.flush = function() {
		var e;
		e = this;
		if (!(go$interfaceIsEqual(e.err, null))) {
			return;
		}
		e.err = e.w.Flush();
	};
	encoder.prototype.flush = function() { return this.go$val.flush(); };
 0Ç  Åˇ	encoder.Ptr.prototype.write = function(p) {
		var e, _tuple;
		e = this;
		if (!(go$interfaceIsEqual(e.err, null))) {
			return;
		}
		_tuple = e.w.Write(p), e.err = _tuple[1];
	};
	encoder.prototype.write = function(p) { return this.go$val.write(p); };
 0Å¸  ÅÛ	encoder.Ptr.prototype.writeByte = function(b) {
		var e;
		e = this;
		if (!(go$interfaceIsEqual(e.err, null))) {
			return;
		}
		e.err = e.w.WriteByte(b);
	};
	encoder.prototype.writeByte = function(b) { return this.go$val.writeByte(b); };
 0ÇØ  Ç•	encoder.Ptr.prototype.writeHeader = function() {
		var e, _tuple, _slice, _index, pm, _tuple$1;
		e = this;
		if (!(go$interfaceIsEqual(e.err, null))) {
			return;
		}
		_tuple = io.WriteString(e.w, "GIF89a"), e.err = _tuple[1];
		if (!(go$interfaceIsEqual(e.err, null))) {
			return;
		}
		pm = (_slice = e.g.Image, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		writeUint16(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0, 2), (pm.Bounds().Dx() << 16 >>> 16));
		writeUint16(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 2, 4), (pm.Bounds().Dy() << 16 >>> 16));
		e.write(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0, 4));
		e.buf[0] = 0;
		e.buf[1] = 0;
		e.buf[2] = 0;
		e.write(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0, 3));
		if (e.g.Image.length > 1) {
			e.buf[0] = 33;
			e.buf[1] = 255;
			e.buf[2] = 11;
			e.write(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0, 3));
			_tuple$1 = io.WriteString(e.w, "NETSCAPE2.0"), e.err = _tuple$1[1];
			if (!(go$interfaceIsEqual(e.err, null))) {
				return;
			}
			e.buf[0] = 3;
			e.buf[1] = 1;
			writeUint16(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 2, 4), (e.g.LoopCount << 16 >>> 16));
			e.buf[4] = 0;
			e.write(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0, 5));
		}
	};
	encoder.prototype.writeHeader = function() { return this.go$val.writeHeader(); };
 0Ç”  Ç…	encoder.Ptr.prototype.writeColorTable = function(p, size) {
		var e, i, _tuple, _slice, _index, r, g, b, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7;
		e = this;
		if (!(go$interfaceIsEqual(e.err, null))) {
			return;
		}
		i = 0;
		while (i < log2Lookup[size]) {
			if (i < p.length) {
				_tuple = (_slice = p, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).RGBA(), r = _tuple[0], g = _tuple[1], b = _tuple[2];
				e.buf[(x = 3, (((x >>> 16 << 16) * i >> 0) + (x << 16 >>> 16) * i) >> 0) + 0 >> 0] = ((r >>> 8 >>> 0) << 24 >>> 24);
				e.buf[(x$1 = 3, (((x$1 >>> 16 << 16) * i >> 0) + (x$1 << 16 >>> 16) * i) >> 0) + 1 >> 0] = ((g >>> 8 >>> 0) << 24 >>> 24);
				e.buf[(x$2 = 3, (((x$2 >>> 16 << 16) * i >> 0) + (x$2 << 16 >>> 16) * i) >> 0) + 2 >> 0] = ((b >>> 8 >>> 0) << 24 >>> 24);
			} else {
				e.buf[(x$3 = 3, (((x$3 >>> 16 << 16) * i >> 0) + (x$3 << 16 >>> 16) * i) >> 0) + 0 >> 0] = 0;
				e.buf[(x$4 = 3, (((x$4 >>> 16 << 16) * i >> 0) + (x$4 << 16 >>> 16) * i) >> 0) + 1 >> 0] = 0;
				e.buf[(x$5 = 3, (((x$5 >>> 16 << 16) * i >> 0) + (x$5 << 16 >>> 16) * i) >> 0) + 2 >> 0] = 0;
			}
			i = i + 1 >> 0;
		}
		e.write(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0, (x$6 = 3, x$7 = log2Lookup[size], (((x$6 >>> 16 << 16) * x$7 >> 0) + (x$6 << 16 >>> 16) * x$7) >> 0)));
	};
	encoder.prototype.writeColorTable = function(p, size) { return this.go$val.writeColorTable(p, size); };
 0Ç
÷  Ç
Ã	encoder.Ptr.prototype.writeImageBlock = function(pm, delay) {
		var e, _struct, _struct$1, _struct$2, b, transparentIndex, _ref, _i, _slice, _index, c, i, a, _tuple, paddedSize, litWidth, x, lzww, _tuple$1;
		e = this;
		if (!(go$interfaceIsEqual(e.err, null))) {
			return;
		}
		if (pm.Palette.length === 0) {
			e.err = errors.New("gif: cannot encode image block with empty palette");
			return;
		}
		b = (_struct = pm.Bounds(), new image.Rectangle.Ptr((_struct$1 = _struct.Min, new image.Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new image.Point.Ptr(_struct$2.X, _struct$2.Y))));
		if (b.Dx() >= 65536 || b.Dy() >= 65536 || b.Min.X < 0 || b.Min.X >= 65536 || b.Min.Y < 0 || b.Min.Y >= 65536) {
			e.err = errors.New("gif: image block is too large to encode");
			return;
		}
		transparentIndex = -1;
		_ref = pm.Palette;
		_i = 0;
		while (_i < _ref.length) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (_tuple = c.RGBA(), a = _tuple[3], a === 0) {
				transparentIndex = i;
				break;
			}
			_i++;
		}
		if (delay > 0 || !((transparentIndex === -1))) {
			e.buf[0] = 33;
			e.buf[1] = 249;
			e.buf[2] = 4;
			if (!((transparentIndex === -1))) {
				e.buf[3] = 1;
			} else {
				e.buf[3] = 0;
			}
			writeUint16(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 4, 6), (delay << 16 >>> 16));
			if (!((transparentIndex === -1))) {
				e.buf[6] = (transparentIndex << 24 >>> 24);
			} else {
				e.buf[6] = 0;
			}
			e.buf[7] = 0;
			e.write(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0, 8));
		}
		e.buf[0] = 44;
		writeUint16(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 1, 3), (b.Min.X << 16 >>> 16));
		writeUint16(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 3, 5), (b.Min.Y << 16 >>> 16));
		writeUint16(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 5, 7), (b.Dx() << 16 >>> 16));
		writeUint16(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 7, 9), (b.Dy() << 16 >>> 16));
		e.write(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0, 9));
		paddedSize = log2(pm.Palette.length);
		e.writeByte((128 | (paddedSize << 24 >>> 24)) >>> 0);
		e.writeColorTable(pm.Palette, paddedSize);
		litWidth = paddedSize + 1 >> 0;
		if (litWidth < 2) {
			litWidth = 2;
		}
		e.writeByte((litWidth << 24 >>> 24));
		lzww = lzw.NewWriter((x = new blockWriter.Ptr(e), new x.constructor.Struct(x)), 0, litWidth);
		_tuple$1 = lzww.Write(pm.Pix), e.err = _tuple$1[1];
		if (!(go$interfaceIsEqual(e.err, null))) {
			lzww.Close();
			return;
		}
		lzww.Close();
		e.writeByte(0);
	};
	encoder.prototype.writeImageBlock = function(pm, delay) { return this.go$val.writeImageBlock(pm, delay); };
 0ÇÀ 	EncodeAllÇ∏	EncodeAll = go$pkg.EncodeAll = function(w, g) {
		var e, ok, _tuple, ww, _ref, _i, _slice, _index, pm, i, _slice$1, _index$1;
		if (g.Image.length === 0) {
			return errors.New("gif: must provide at least one image");
		}
		if (!((g.Image.length === g.Delay.length))) {
			return errors.New("gif: mismatched image and delay lengths");
		}
		if (g.LoopCount < 0) {
			g.LoopCount = 0;
		}
		e = new encoder.Ptr(null, null, g, go$makeNativeArray("Uint8", 1024, function() { return 0; }));
		if (_tuple = (w !== null && writer.implementedBy.indexOf(w.constructor) !== -1 ? [w, true] : [null, false]), ww = _tuple[0], ok = _tuple[1], ok) {
			e.w = ww;
		} else {
			e.w = bufio.NewWriter(w);
		}
		e.writeHeader();
		_ref = g.Image;
		_i = 0;
		while (_i < _ref.length) {
			pm = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			e.writeImageBlock(pm, (_slice$1 = g.Delay, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")));
			_i++;
		}
		e.writeByte(59);
		e.flush();
		return e.err;
	};
 0Ç EncodeÇ˛	Encode = go$pkg.Encode = function(w, m, o) {
		var _struct, _struct$1, _struct$2, b, opts, _struct$3, _tuple, pm, ok, _struct$4, _struct$5, _struct$6, x, _struct$7, _struct$8, _struct$9, _struct$10;
		b = (_struct = m.Bounds(), new image.Rectangle.Ptr((_struct$1 = _struct.Min, new image.Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new image.Point.Ptr(_struct$2.X, _struct$2.Y))));
		if (b.Dx() >= 65536 || b.Dy() >= 65536) {
			return errors.New("gif: image is too large to encode");
		}
		opts = new Options.Ptr(0, null, null);
		if (!(o === (go$ptrType(Options)).nil)) {
			opts = (_struct$3 = o, new Options.Ptr(_struct$3.NumColors, _struct$3.Quantizer, _struct$3.Drawer));
		}
		if (opts.NumColors < 1 || 256 < opts.NumColors) {
			opts.NumColors = 256;
		}
		if (go$interfaceIsEqual(opts.Drawer, null)) {
			opts.Drawer = draw.FloydSteinberg;
		}
		_tuple = (m !== null && m.constructor === (go$ptrType(image.Paletted)) ? [m.go$val, true] : [(go$ptrType(image.Paletted)).nil, false]), pm = _tuple[0], ok = _tuple[1];
		if (!ok || pm.Palette.length > opts.NumColors) {
			pm = image.NewPaletted((_struct$4 = b, new image.Rectangle.Ptr((_struct$5 = _struct$4.Min, new image.Point.Ptr(_struct$5.X, _struct$5.Y)), (_struct$6 = _struct$4.Max, new image.Point.Ptr(_struct$6.X, _struct$6.Y)))), (x = go$subslice(palette.Plan9, 0, opts.NumColors), go$subslice(new color.Palette(x.array), x.offset, x.offset + x.length)));
			if (!(go$interfaceIsEqual(opts.Quantizer, null))) {
				pm.Palette = opts.Quantizer.Quantize(color.Palette.make(0, opts.NumColors, function() { return null; }), m);
			}
			opts.Drawer.Draw(pm, (_struct$7 = b, new image.Rectangle.Ptr((_struct$8 = _struct$7.Min, new image.Point.Ptr(_struct$8.X, _struct$8.Y)), (_struct$9 = _struct$7.Max, new image.Point.Ptr(_struct$9.X, _struct$9.Y)))), m, (_struct$10 = image.ZP, new image.Point.Ptr(_struct$10.X, _struct$10.Y)));
		}
		return EncodeAll(w, new GIF.Ptr(new (go$sliceType((go$ptrType(image.Paletted))))([pm]), new (go$sliceType(Go$Int))([0]), 0));
	};
 0 errNotEnough  0 
errTooMuch  0 errBadPixel  0 interlacing  0 
log2Lookup  0C   ;		errNotEnough = errors.New("gif: not enough image data");
0?   7		errTooMuch = errors.New("gif: too much image data");
0@   8		errBadPixel = errors.New("gif: invalid pixel value");
0Å≤   Å©		interlacing = new (go$sliceType(interlaceScan))([new interlaceScan.Ptr(8, 0), new interlaceScan.Ptr(8, 4), new interlaceScan.Ptr(4, 2), new interlaceScan.Ptr(2, 1)]);
0Q   I		log2Lookup = go$toNativeArray("Int", [2, 4, 8, 16, 32, 64, 128, 256]);
0    0G   ?		image.RegisterFormat("gif", "GIF8?a", Decode, DecodeConfig);
0 