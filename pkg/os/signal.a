0‚¾‚Ÿpackage signal
import os "os"
import sync "sync"
import syscall "syscall"
func @"".Notify(@"".c chan<- @"os".Signal, @"".sig ...@"os".Signal) ()
func @"".Stop(@"".c chan<- @"os".Signal) ()
type @"".handler struct { @"".mask [3]uint32 }
func (? *@"".handler) @"".set(@"".sig int) ()
func (? *@"".handler) @"".want(@"".sig int) (? bool)
type @"os".Signal interface { @"os".Signal() (); @"os".String() (? string) }
$$
0Fruntimeerrorssync/atomicsynciosyscalltimeos	os/signal‚Ï	var os = go$packages["os"];
	var sync = go$packages["sync"];
	var syscall = go$packages["syscall"];
	var handler;
	handler = go$newType(0, "Struct", "signal.handler", "handler", "os/signal", function(mask_) {
		this.go$val = this;
		this.mask = mask_ !== undefined ? mask_ : go$makeNativeArray("Uint32", 3, function() { return 0; });
	});
	go$pkg.handler = handler;
	handler.init([["mask", "os/signal", (go$arrayType(Go$Uint32, 3)), ""]]);
	(go$ptrType(handler)).methods = [["set", "os/signal", [Go$Int], [], false], ["want", "os/signal", [Go$Int], [Go$Bool], false]];
	handler.Ptr.prototype.want = function(sig) {
		var h, y, _q;
		h = this;
		return !(((((((y = ((sig & 31) >>> 0), y < 32 ? (h.mask[(_q = sig / 32, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"))] >>> y) : 0) >>> 0)) & 1) >>> 0) === 0));
	};
	handler.prototype.want = function(sig) { return this.go$val.want(sig); };
	handler.Ptr.prototype.set = function(sig) {
		var h, _lhs, _index, _q, y;
		h = this;
		_lhs = h.mask, _index = (_q = sig / 32, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")), _lhs[_index] = (_lhs[_index] | (((y = ((sig & 31) >>> 0), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0;
	};
	handler.prototype.set = function(sig) { return this.go$val.set(sig); };
	var Notify = go$pkg.Notify = function(c, sig) {
		var _entry, h, _key, add, n, _ref, _i, _slice, _index, s;
		var go$deferred = [];
		try {
			if (c === (go$chanType(os.Signal, true, false)).nil) {
				throw go$panic(new Go$String("os/signal: Notify using nil channel"));
			}
			handlers.Mutex.Lock();
			go$deferred.push({ recv: handlers, method: "Unlock", args: [] });
			h = (_entry = handlers.m[c.go$key()], _entry !== undefined ? _entry.v : (go$ptrType(handler)).nil);
			if (h === (go$ptrType(handler)).nil) {
				if (handlers.m === false) {
					handlers.m = new Go$Map();
				}
				h = new handler.Ptr();
				_key = c, (handlers.m || go$throwRuntimeError("assignment to entry in nil map"))[_key.go$key()] = { k: _key, v: h };
			}
			add = (function(n) {
				var x, _lhs, _index, x$1;
				if (n < 0) {
					return;
				}
				if (!h.want(n)) {
					h.set(n);
					if ((x = handlers.ref[n], (x.high === 0 && x.low === 0))) {
						enableSignal(n);
					}
					_lhs = handlers.ref, _index = n, _lhs[_index] = (x$1 = _lhs[_index], new Go$Int64(x$1.high + 0, x$1.low + 1));
				}
			});
			if (sig.length === 0) {
				n = 0;
				while (n < 65) {
					add(n);
					n = n + 1 >> 0;
				}
			} else {
				_ref = sig;
				_i = 0;
				for (; _i < _ref.length; _i += 1) {
					s = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
					add(signum(s));
				}
			}
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	var Stop = go$pkg.Stop = function(c) {
		var _entry, h, n, _lhs, _index, x, x$1;
		var go$deferred = [];
		try {
			handlers.Mutex.Lock();
			go$deferred.push({ recv: handlers, method: "Unlock", args: [] });
			h = (_entry = handlers.m[c.go$key()], _entry !== undefined ? _entry.v : (go$ptrType(handler)).nil);
			if (h === (go$ptrType(handler)).nil) {
				return;
			}
			delete handlers.m[c.go$key()];
			n = 0;
			while (n < 65) {
				if (h.want(n)) {
					_lhs = handlers.ref, _index = n, _lhs[_index] = (x = _lhs[_index], new Go$Int64(x.high - 0, x.low - 1));
					if ((x$1 = handlers.ref[n], (x$1.high === 0 && x$1.low === 0))) {
						disableSignal(n);
					}
				}
				n = n + 1 >> 0;
			}
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	var process = function(sig) {
		var n, _ref, _i, _keys, _entry, h, c;
		var go$deferred = [];
		try {
			n = signum(sig);
			if (n < 0) {
				return;
			}
			handlers.Mutex.Lock();
			go$deferred.push({ recv: handlers, method: "Unlock", args: [] });
			_ref = handlers.m;
			_i = 0;
			_keys = go$keys(_ref);
			for (; _i < _keys.length; _i += 1) {
				_entry = _ref[_keys[_i]];
				h = _entry.v;
				c = _entry.k;
				if (h.want(n)) {
					go$notSupported("select")
				}
			}
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	var signal_disable = function() {
		throw go$panic("Native function not implemented: signal_disable");
	};
	var signal_enable = function() {
		throw go$panic("Native function not implemented: signal_enable");
	};
	var signal_recv = function() {
		throw go$panic("Native function not implemented: signal_recv");
	};
	var loop = function() {
		while (true) {
			process(new syscall.Signal((signal_recv() >> 0)));
		}
	};
	var signum = function(sig) {
		var sig$1, _ref, _type, i;
		_ref = sig;
		_type = _ref !== null ? _ref.constructor : null;
		if (_type === syscall.Signal) {
			sig$1 = _ref.go$val;
			i = (sig$1 >> 0);
			if (i < 0 || i >= 65) {
				return -1;
			}
			return i;
		} else {
			sig$1 = _ref;
			return -1;
		}
	};
	var enableSignal = function(sig) {
		signal_enable((sig >>> 0));
	};
	var disableSignal = function(sig) {
		signal_disable((sig >>> 0));
	};
	var numSig = 65;
	var handlers = new (go$structType([["", "", sync.Mutex, ""], ["m", "os/signal", (go$mapType((go$chanType(os.Signal, true, false)), (go$ptrType(handler)))), ""], ["ref", "os/signal", (go$arrayType(Go$Int64, 65)), ""]])).Ptr(new sync.Mutex.Ptr(), false, go$makeNativeArray("Int64", 65, function() { return new Go$Int64(0, 0); }));
	go$pkg.init = function() {
		signal_enable(0);
		go$notSupported("go")
	};
