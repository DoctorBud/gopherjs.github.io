0ÇVìencoding/csvÇÍpackage csv
import bufio "bufio"
import bytes "bytes"
import errors "errors"
import fmt "fmt"
import io "io"
import unicode "unicode"
import strings "strings"
import utf8 "unicode/utf8"
var @"".ErrBareQuote error
var @"".ErrFieldCount error
var @"".ErrQuote error
var @"".ErrTrailingComma error
func @"".NewReader(@"".r @"io".Reader) (? *@"".Reader)
func @"".NewWriter(@"".w @"io".Writer) (? *@"".Writer)
type @"".ParseError struct { @"".Line int; @"".Column int; @"".Err error }
func (? *@"".ParseError) @"".Error() (? string)
type @"".Reader struct { @"".Comma rune; @"".Comment rune; @"".FieldsPerRecord int; @"".LazyQuotes bool; @"".TrailingComma bool; @"".TrimLeadingSpace bool; @"".line int; @"".column int; @"".r *@"bufio".Reader; @"".field @"bytes".Buffer }
func (? *@"".Reader) @"".Read() (@"".record []string, @"".err error)
func (? *@"".Reader) @"".ReadAll() (@"".records [][]string, @"".err error)
func (? *@"".Reader) @"".error(@"".err error) (? error)
func (? *@"".Reader) @"".parseField() (@"".haveField bool, @"".delim rune, @"".err error)
func (? *@"".Reader) @"".parseRecord() (@"".fields []string, @"".err error)
func (? *@"".Reader) @"".readRune() (? rune, ? error)
func (? *@"".Reader) @"".skip(@"".delim rune) (? error)
func (? *@"".Reader) @"".unreadRune() ()
type @"".Writer struct { @"".Comma rune; @"".UseCRLF bool; @"".w *@"bufio".Writer }
func (? *@"".Writer) @"".Error() (? error)
func (? *@"".Writer) @"".Flush() ()
func (? *@"".Writer) @"".Write(@"".record []string) (@"".err error)
func (? *@"".Writer) @"".WriteAll(@"".records [][]string) (@"".err error)
func (? *@"".Writer) @"".fieldNeedsQuotes(@"".field string) (? bool)
type @"io".Reader interface { @"io".Read(@"".p []byte) (@"".n int, @"".err error) }
type @"io".Writer interface { @"io".Write(@"".p []byte) (@"".n int, @"".err error) }
type @"bufio".Reader struct { @"bufio".buf []byte; @"bufio".rd @"io".Reader; @"bufio".r int; @"bufio".w int; @"bufio".err error; @"bufio".lastByte int; @"bufio".lastRuneSize int }
func (? *@"bufio".Reader) @"bufio".Buffered() (? int)
func (? *@"bufio".Reader) @"bufio".Peek(@"".n int) (? []byte, ? error)
func (? *@"bufio".Reader) @"bufio".Read(@"".p []byte) (@"".n int, @"".err error)
func (? *@"bufio".Reader) @"bufio".ReadByte() (@"".c byte, @"".err error)
func (? *@"bufio".Reader) @"bufio".ReadBytes(@"".delim byte) (@"".line []byte, @"".err error)
func (? *@"bufio".Reader) @"bufio".ReadLine() (@"".line []byte, @"".isPrefix bool, @"".err error)
func (? *@"bufio".Reader) @"bufio".ReadRune() (@"".r rune, @"".size int, @"".err error)
func (? *@"bufio".Reader) @"bufio".ReadSlice(@"".delim byte) (@"".line []byte, @"".err error)
func (? *@"bufio".Reader) @"bufio".ReadString(@"".delim byte) (@"".line string, @"".err error)
func (? *@"bufio".Reader) @"bufio".Reset(@"".r @"io".Reader) ()
func (? *@"bufio".Reader) @"bufio".UnreadByte() (? error)
func (? *@"bufio".Reader) @"bufio".UnreadRune() (? error)
func (? *@"bufio".Reader) @"bufio".WriteTo(@"".w @"io".Writer) (@"".n int64, @"".err error)
func (? *@"bufio".Reader) @"bufio".fill() ()
func (? *@"bufio".Reader) @"bufio".readErr() (? error)
func (? *@"bufio".Reader) @"bufio".reset(@"".buf []byte, @"".r @"io".Reader) ()
func (? *@"bufio".Reader) @"bufio".writeBuf(@"".w @"io".Writer) (? int64, ? error)
type @"bytes".Buffer struct { @"bytes".buf []byte; @"bytes".off int; @"bytes".runeBytes [4]byte; @"bytes".bootstrap [64]byte; @"bytes".lastRead @"bytes".readOp }
func (? *@"bytes".Buffer) @"bytes".Bytes() (? []byte)
func (? *@"bytes".Buffer) @"bytes".Grow(@"".n int) ()
func (? *@"bytes".Buffer) @"bytes".Len() (? int)
func (? *@"bytes".Buffer) @"bytes".Next(@"".n int) (? []byte)
func (? *@"bytes".Buffer) @"bytes".Read(@"".p []byte) (@"".n int, @"".err error)
func (? *@"bytes".Buffer) @"bytes".ReadByte() (@"".c byte, @"".err error)
func (? *@"bytes".Buffer) @"bytes".ReadBytes(@"".delim byte) (@"".line []byte, @"".err error)
func (? *@"bytes".Buffer) @"bytes".ReadFrom(@"".r @"io".Reader) (@"".n int64, @"".err error)
func (? *@"bytes".Buffer) @"bytes".ReadRune() (@"".r rune, @"".size int, @"".err error)
func (? *@"bytes".Buffer) @"bytes".ReadString(@"".delim byte) (@"".line string, @"".err error)
func (? *@"bytes".Buffer) @"bytes".Reset() ()
func (? *@"bytes".Buffer) @"bytes".String() (? string)
func (? *@"bytes".Buffer) @"bytes".Truncate(@"".n int) ()
func (? *@"bytes".Buffer) @"bytes".UnreadByte() (? error)
func (? *@"bytes".Buffer) @"bytes".UnreadRune() (? error)
func (? *@"bytes".Buffer) @"bytes".Write(@"".p []byte) (@"".n int, @"".err error)
func (? *@"bytes".Buffer) @"bytes".WriteByte(@"".c byte) (? error)
func (? *@"bytes".Buffer) @"bytes".WriteRune(@"".r rune) (@"".n int, @"".err error)
func (? *@"bytes".Buffer) @"bytes".WriteString(@"".s string) (@"".n int, @"".err error)
func (? *@"bytes".Buffer) @"bytes".WriteTo(@"".w @"io".Writer) (@"".n int64, @"".err error)
func (? *@"bytes".Buffer) @"bytes".grow(@"".n int) (? int)
func (? *@"bytes".Buffer) @"bytes".readSlice(@"".delim byte) (@"".line []byte, @"".err error)
type @"bufio".Writer struct { @"bufio".err error; @"bufio".buf []byte; @"bufio".n int; @"bufio".wr @"io".Writer }
func (? *@"bufio".Writer) @"bufio".Available() (? int)
func (? *@"bufio".Writer) @"bufio".Buffered() (? int)
func (? *@"bufio".Writer) @"bufio".Flush() (? error)
func (? *@"bufio".Writer) @"bufio".ReadFrom(@"".r @"io".Reader) (@"".n int64, @"".err error)
func (? *@"bufio".Writer) @"bufio".Reset(@"".w @"io".Writer) ()
func (? *@"bufio".Writer) @"bufio".Write(@"".p []byte) (@"".nn int, @"".err error)
func (? *@"bufio".Writer) @"bufio".WriteByte(@"".c byte) (? error)
func (? *@"bufio".Writer) @"bufio".WriteRune(@"".r rune) (@"".size int, @"".err error)
func (? *@"bufio".Writer) @"bufio".WriteString(@"".s string) (? int, ? error)
func (? *@"bufio".Writer) @"bufio".flush() (? error)
type @"bytes".readOp int
$$
0Åîruntimeerrorssync/atomicsynciounicodeunicode/utf8bytesbufiomathsyscalltimeosstrconvreflectfmtstringsencoding/csv0ÅÜ0bufiobufio0bytesbytes0errorserrors0
fmtfmt0ioio0unicodeunicode0stringsstrings0unicode/utf8utf8Ç~	var ParseError;
	ParseError = go$newType(0, "Struct", "csv.ParseError", "ParseError", "encoding/csv", function(Line_, Column_, Err_) {
		this.go$val = this;
		this.Line = Line_ !== undefined ? Line_ : 0;
		this.Column = Column_ !== undefined ? Column_ : 0;
		this.Err = Err_ !== undefined ? Err_ : null;
	});
	go$pkg.ParseError = ParseError;
	var Reader;
	Reader = go$newType(0, "Struct", "csv.Reader", "Reader", "encoding/csv", function(Comma_, Comment_, FieldsPerRecord_, LazyQuotes_, TrailingComma_, TrimLeadingSpace_, line_, column_, r_, field_) {
		this.go$val = this;
		this.Comma = Comma_ !== undefined ? Comma_ : 0;
		this.Comment = Comment_ !== undefined ? Comment_ : 0;
		this.FieldsPerRecord = FieldsPerRecord_ !== undefined ? FieldsPerRecord_ : 0;
		this.LazyQuotes = LazyQuotes_ !== undefined ? LazyQuotes_ : false;
		this.TrailingComma = TrailingComma_ !== undefined ? TrailingComma_ : false;
		this.TrimLeadingSpace = TrimLeadingSpace_ !== undefined ? TrimLeadingSpace_ : false;
		this.line = line_ !== undefined ? line_ : 0;
		this.column = column_ !== undefined ? column_ : 0;
		this.r = r_ !== undefined ? r_ : (go$ptrType(bufio.Reader)).nil;
		this.field = field_ !== undefined ? field_ : new bytes.Buffer.Ptr();
	});
	go$pkg.Reader = Reader;
	var Writer;
	Writer = go$newType(0, "Struct", "csv.Writer", "Writer", "encoding/csv", function(Comma_, UseCRLF_, w_) {
		this.go$val = this;
		this.Comma = Comma_ !== undefined ? Comma_ : 0;
		this.UseCRLF = UseCRLF_ !== undefined ? UseCRLF_ : false;
		this.w = w_ !== undefined ? w_ : (go$ptrType(bufio.Writer)).nil;
	});
	go$pkg.Writer = Writer;
	ParseError.init([["Line", "", Go$Int, ""], ["Column", "", Go$Int, ""], ["Err", "", go$error, ""]]);
	(go$ptrType(ParseError)).methods = [["Error", "", [], [Go$String], false]];
	Reader.init([["Comma", "", Go$Int32, ""], ["Comment", "", Go$Int32, ""], ["FieldsPerRecord", "", Go$Int, ""], ["LazyQuotes", "", Go$Bool, ""], ["TrailingComma", "", Go$Bool, ""], ["TrimLeadingSpace", "", Go$Bool, ""], ["line", "encoding/csv", Go$Int, ""], ["column", "encoding/csv", Go$Int, ""], ["r", "encoding/csv", (go$ptrType(bufio.Reader)), ""], ["field", "encoding/csv", bytes.Buffer, ""]]);
	(go$ptrType(Reader)).methods = [["Read", "", [], [(go$sliceType(Go$String)), go$error], false], ["ReadAll", "", [], [(go$sliceType((go$sliceType(Go$String)))), go$error], false], ["error", "encoding/csv", [go$error], [go$error], false], ["parseField", "encoding/csv", [], [Go$Bool, Go$Int32, go$error], false], ["parseRecord", "encoding/csv", [], [(go$sliceType(Go$String)), go$error], false], ["readRune", "encoding/csv", [], [Go$Int32, go$error], false], ["skip", "encoding/csv", [Go$Int32], [go$error], false], ["unreadRune", "encoding/csv", [], [], false]];
	Writer.init([["Comma", "", Go$Int32, ""], ["UseCRLF", "", Go$Bool, ""], ["w", "encoding/csv", (go$ptrType(bufio.Writer)), ""]]);
	(go$ptrType(Writer)).methods = [["Error", "", [], [go$error], false], ["Flush", "", [], [], false], ["Write", "", [(go$sliceType(Go$String))], [go$error], false], ["WriteAll", "", [(go$sliceType((go$sliceType(Go$String))))], [go$error], false], ["fieldNeedsQuotes", "encoding/csv", [Go$String], [Go$Bool], false]];
u	go$pkg.ErrTrailingComma = null;
	go$pkg.ErrBareQuote = null;
	go$pkg.ErrQuote = null;
	go$pkg.ErrFieldCount = null;
0Ç1z0Ç'ErrorÇ	ParseError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return fmt.Sprintf("line %d, column %d: %s", new (go$sliceType(go$emptyInterface))([new Go$Int(e.Line), new Go$Int(e.Column), e.Err]));
	};
	ParseError.prototype.Error = function() { return this.go$val.Error(); };
0ÅÆ	NewReaderÅ†	var NewReader = go$pkg.NewReader = function(r) {
		return new Reader.Ptr(44, 0, 0, false, false, false, 0, 0, bufio.NewReader(r), new bytes.Buffer.Ptr());
	};
0Å—errorÅ«	Reader.Ptr.prototype.error = function(err) {
		var r;
		r = this;
		return new ParseError.Ptr(r.line, r.column, err);
	};
	Reader.prototype.error = function(err) { return this.go$val.error(err); };
0Ç÷ReadÇÃ	Reader.Ptr.prototype.Read = function() {
		var record, err, r, _tuple, _tuple$1, _tuple$2, _tuple$3;
		record = (go$sliceType(Go$String)).nil;
		err = null;
		r = this;
		while (true) {
			_tuple = r.parseRecord(), record = _tuple[0], err = _tuple[1];
			if (!(record === (go$sliceType(Go$String)).nil)) {
				break;
			}
			if (!(go$interfaceIsEqual(err, null))) {
				_tuple$1 = [(go$sliceType(Go$String)).nil, err], record = _tuple$1[0], err = _tuple$1[1];
				return [record, err];
			}
		}
		if (r.FieldsPerRecord > 0) {
			if (!((record.length === r.FieldsPerRecord))) {
				r.column = 0;
				_tuple$2 = [record, r.error(go$pkg.ErrFieldCount)], record = _tuple$2[0], err = _tuple$2[1];
				return [record, err];
			}
		} else if (r.FieldsPerRecord === 0) {
			r.FieldsPerRecord = record.length;
		}
		_tuple$3 = [record, null], record = _tuple$3[0], err = _tuple$3[1];
		return [record, err];
	};
	Reader.prototype.Read = function() { return this.go$val.Read(); };
0ÇReadAllÇ„	Reader.Ptr.prototype.ReadAll = function() {
		var records, err, r, _tuple, record, err$1, _tuple$1, _tuple$2;
		records = (go$sliceType((go$sliceType(Go$String)))).nil;
		err = null;
		r = this;
		while (true) {
			_tuple = r.Read(), record = _tuple[0], err$1 = _tuple[1];
			if (go$interfaceIsEqual(err$1, io.EOF)) {
				_tuple$1 = [records, null], records = _tuple$1[0], err = _tuple$1[1];
				return [records, err];
			}
			if (!(go$interfaceIsEqual(err$1, null))) {
				_tuple$2 = [(go$sliceType((go$sliceType(Go$String)))).nil, err$1], records = _tuple$2[0], err = _tuple$2[1];
				return [records, err];
			}
			records = go$append(records, record);
		}
	};
	Reader.prototype.ReadAll = function() { return this.go$val.ReadAll(); };
0Ç˘readRuneÇÎ	Reader.Ptr.prototype.readRune = function() {
		var r, _tuple, r1, err, _tuple$1;
		r = this;
		_tuple = r.r.ReadRune(), r1 = _tuple[0], err = _tuple[2];
		if (r1 === 13) {
			_tuple$1 = r.r.ReadRune(), r1 = _tuple$1[0], err = _tuple$1[2];
			if (go$interfaceIsEqual(err, null)) {
				if (!((r1 === 10))) {
					r.r.UnreadRune();
					r1 = 13;
				}
			}
		}
		r.column = r.column + 1 >> 0;
		return [r1, err];
	};
	Reader.prototype.readRune = function() { return this.go$val.readRune(); };
0Å‹
unreadRuneÅÕ	Reader.Ptr.prototype.unreadRune = function() {
		var r;
		r = this;
		r.r.UnreadRune();
		r.column = r.column - 1 >> 0;
	};
	Reader.prototype.unreadRune = function() { return this.go$val.unreadRune(); };
0ÇoskipÇe	Reader.Ptr.prototype.skip = function(delim) {
		var r, _tuple, r1, err;
		r = this;
		while (true) {
			_tuple = r.readRune(), r1 = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return err;
			}
			if (r1 === delim) {
				return null;
			}
		}
	};
	Reader.prototype.skip = function(delim) { return this.go$val.skip(delim); };
0Ç7parseRecordÇ&	Reader.Ptr.prototype.parseRecord = function() {
		var fields, err, r, _tuple, r1, _tuple$1, _tuple$2, _tuple$3, haveField, delim, err$1, _tuple$4, _tuple$5;
		fields = (go$sliceType(Go$String)).nil;
		err = null;
		r = this;
		r.line = r.line + 1 >> 0;
		r.column = -1;
		_tuple = r.r.ReadRune(), r1 = _tuple[0], err = _tuple[2];
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$1 = [(go$sliceType(Go$String)).nil, err], fields = _tuple$1[0], err = _tuple$1[1];
			return [fields, err];
		}
		if (!((r.Comment === 0)) && (r1 === r.Comment)) {
			_tuple$2 = [(go$sliceType(Go$String)).nil, r.skip(10)], fields = _tuple$2[0], err = _tuple$2[1];
			return [fields, err];
		}
		r.r.UnreadRune();
		while (true) {
			_tuple$3 = r.parseField(), haveField = _tuple$3[0], delim = _tuple$3[1], err$1 = _tuple$3[2];
			if (haveField) {
				fields = go$append(fields, r.field.String());
			}
			if ((delim === 10) || go$interfaceIsEqual(err$1, io.EOF)) {
				_tuple$4 = [fields, err$1], fields = _tuple$4[0], err = _tuple$4[1];
				return [fields, err];
			} else if (!(go$interfaceIsEqual(err$1, null))) {
				_tuple$5 = [(go$sliceType(Go$String)).nil, err$1], fields = _tuple$5[0], err = _tuple$5[1];
				return [fields, err];
			}
		}
	};
	Reader.prototype.parseRecord = function() { return this.go$val.parseRecord(); };
0Ç∫
parseFieldÇ™	Reader.Ptr.prototype.parseField = function() {
		var haveField, delim, err, r, _tuple, r1, _tuple$1, _tuple$2, _tuple$3, _ref, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, _tuple$9, _ref$1, _tuple$10, _tuple$11, _tuple$12, _tuple$13, _tuple$14, _tuple$15, _tuple$16, _tuple$17, _tuple$18;
		haveField = false;
		delim = 0;
		err = null;
		r = this;
		r.field.Reset();
		_tuple = r.readRune(), r1 = _tuple[0], err = _tuple[1];
		while (go$interfaceIsEqual(err, null) && r.TrimLeadingSpace && !((r1 === 10)) && unicode.IsSpace(r1)) {
			_tuple$1 = r.readRune(), r1 = _tuple$1[0], err = _tuple$1[1];
		}
		if (go$interfaceIsEqual(err, io.EOF) && !((r.column === 0))) {
			_tuple$2 = [true, 0, err], haveField = _tuple$2[0], delim = _tuple$2[1], err = _tuple$2[2];
			return [haveField, delim, err];
		}
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$3 = [false, 0, err], haveField = _tuple$3[0], delim = _tuple$3[1], err = _tuple$3[2];
			return [haveField, delim, err];
		}
		_ref = r1;
		if (_ref === r.Comma) {
		} else if (_ref === 10) {
			if (r.column === 0) {
				_tuple$4 = [false, r1, null], haveField = _tuple$4[0], delim = _tuple$4[1], err = _tuple$4[2];
				return [haveField, delim, err];
			}
			_tuple$5 = [true, r1, null], haveField = _tuple$5[0], delim = _tuple$5[1], err = _tuple$5[2];
			return [haveField, delim, err];
		} else if (_ref === 34) {
			Quoted: while (true) {
				_tuple$6 = r.readRune(), r1 = _tuple$6[0], err = _tuple$6[1];
				if (!(go$interfaceIsEqual(err, null))) {
					if (go$interfaceIsEqual(err, io.EOF)) {
						if (r.LazyQuotes) {
							_tuple$7 = [true, 0, err], haveField = _tuple$7[0], delim = _tuple$7[1], err = _tuple$7[2];
							return [haveField, delim, err];
						}
						_tuple$8 = [false, 0, r.error(go$pkg.ErrQuote)], haveField = _tuple$8[0], delim = _tuple$8[1], err = _tuple$8[2];
						return [haveField, delim, err];
					}
					_tuple$9 = [false, 0, err], haveField = _tuple$9[0], delim = _tuple$9[1], err = _tuple$9[2];
					return [haveField, delim, err];
				}
				_ref$1 = r1;
				if (_ref$1 === 34) {
					_tuple$10 = r.readRune(), r1 = _tuple$10[0], err = _tuple$10[1];
					if (!(go$interfaceIsEqual(err, null)) || (r1 === r.Comma)) {
						break Quoted;
					}
					if (r1 === 10) {
						_tuple$11 = [true, r1, null], haveField = _tuple$11[0], delim = _tuple$11[1], err = _tuple$11[2];
						return [haveField, delim, err];
					}
					if (!((r1 === 34))) {
						if (!r.LazyQuotes) {
							r.column = r.column - 1 >> 0;
							_tuple$12 = [false, 0, r.error(go$pkg.ErrQuote)], haveField = _tuple$12[0], delim = _tuple$12[1], err = _tuple$12[2];
							return [haveField, delim, err];
						}
						r.field.WriteRune(34);
					}
				} else if (_ref$1 === 10) {
					r.line = r.line + 1 >> 0;
					r.column = -1;
				}
				r.field.WriteRune(r1);
			}
		} else {
			while (true) {
				r.field.WriteRune(r1);
				_tuple$13 = r.readRune(), r1 = _tuple$13[0], err = _tuple$13[1];
				if (!(go$interfaceIsEqual(err, null)) || (r1 === r.Comma)) {
					break;
				}
				if (r1 === 10) {
					_tuple$14 = [true, r1, null], haveField = _tuple$14[0], delim = _tuple$14[1], err = _tuple$14[2];
					return [haveField, delim, err];
				}
				if (!r.LazyQuotes && (r1 === 34)) {
					_tuple$15 = [false, 0, r.error(go$pkg.ErrBareQuote)], haveField = _tuple$15[0], delim = _tuple$15[1], err = _tuple$15[2];
					return [haveField, delim, err];
				}
			}
		}
		if (!(go$interfaceIsEqual(err, null))) {
			if (go$interfaceIsEqual(err, io.EOF)) {
				_tuple$16 = [true, 0, err], haveField = _tuple$16[0], delim = _tuple$16[1], err = _tuple$16[2];
				return [haveField, delim, err];
			}
			_tuple$17 = [false, 0, err], haveField = _tuple$17[0], delim = _tuple$17[1], err = _tuple$17[2];
			return [haveField, delim, err];
		}
		_tuple$18 = [true, r1, null], haveField = _tuple$18[0], delim = _tuple$18[1], err = _tuple$18[2];
		return [haveField, delim, err];
	};
	Reader.prototype.parseField = function() { return this.go$val.parseField(); };
0{	NewWritern	var NewWriter = go$pkg.NewWriter = function(w) {
		return new Writer.Ptr(44, false, bufio.NewWriter(w));
	};
0Ç2WriteÇ'	Writer.Ptr.prototype.Write = function(record) {
		var err, w, _ref, _i, _slice, _index, field, n, _tuple, _tuple$1, _ref$1, _i$1, _rune, r1, _ref$2, _tuple$2, _tuple$3, _tuple$4, _tuple$5;
		err = null;
		w = this;
		_ref = record;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			field = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			n = _i;
			if (n > 0) {
				if (_tuple = w.w.WriteRune(w.Comma), err = _tuple[1], !(go$interfaceIsEqual(err, null))) {
					return err;
				}
			}
			if (!w.fieldNeedsQuotes(field)) {
				if (_tuple$1 = w.w.WriteString(field), err = _tuple$1[1], !(go$interfaceIsEqual(err, null))) {
					return err;
				}
				continue;
			}
			if (err = w.w.WriteByte(34), !(go$interfaceIsEqual(err, null))) {
				return err;
			}
			_ref$1 = field;
			_i$1 = 0;
			for (; _i$1 < _ref$1.length; _i$1 += _rune[1]) {
				_rune = go$decodeRune(_ref$1, _i$1);
				r1 = _rune[0];
				_ref$2 = r1;
				if (_ref$2 === 34) {
					_tuple$2 = w.w.WriteString("\"\""), err = _tuple$2[1];
				} else if (_ref$2 === 13) {
					if (!w.UseCRLF) {
						err = w.w.WriteByte(13);
					}
				} else if (_ref$2 === 10) {
					if (w.UseCRLF) {
						_tuple$3 = w.w.WriteString("\r\n"), err = _tuple$3[1];
					} else {
						err = w.w.WriteByte(10);
					}
				} else {
					_tuple$4 = w.w.WriteRune(r1), err = _tuple$4[1];
				}
				if (!(go$interfaceIsEqual(err, null))) {
					return err;
				}
			}
			if (err = w.w.WriteByte(34), !(go$interfaceIsEqual(err, null))) {
				return err;
			}
		}
		if (w.UseCRLF) {
			_tuple$5 = w.w.WriteString("\r\n"), err = _tuple$5[1];
		} else {
			err = w.w.WriteByte(10);
		}
		return err;
	};
	Writer.prototype.Write = function(record) { return this.go$val.Write(record); };
0Å£FlushÅô	Writer.Ptr.prototype.Flush = function() {
		var w;
		w = this;
		w.w.Flush();
	};
	Writer.prototype.Flush = function() { return this.go$val.Flush(); };
0ÅÙErrorÅÍ	Writer.Ptr.prototype.Error = function() {
		var w, _tuple, err;
		w = this;
		_tuple = w.w.Write((go$sliceType(Go$Uint8)).nil), err = _tuple[1];
		return err;
	};
	Writer.prototype.Error = function() { return this.go$val.Error(); };
0ÇeWriteAllÇW	Writer.Ptr.prototype.WriteAll = function(records) {
		var err, w, _ref, _i, _slice, _index, record;
		err = null;
		w = this;
		_ref = records;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			record = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			err = w.Write(record);
			if (!(go$interfaceIsEqual(err, null))) {
				err = err;
				return err;
			}
		}
		err = w.w.Flush();
		return err;
	};
	Writer.prototype.WriteAll = function(records) { return this.go$val.WriteAll(records); };
0ÇªfieldNeedsQuotesÇ•	Writer.Ptr.prototype.fieldNeedsQuotes = function(field) {
		var w, _tuple, r1;
		w = this;
		if ((field.length === 0) || strings.IndexRune(field, w.Comma) >= 0 || strings.IndexAny(field, "\"\r\n") >= 0) {
			return true;
		}
		_tuple = utf8.DecodeRuneInString(field), r1 = _tuple[0];
		return unicode.IsSpace(r1);
	};
	Writer.prototype.fieldNeedsQuotes = function(field) { return this.go$val.fieldNeedsQuotes(field); };
0Ç8initÇ.	go$pkg.init = function() {
		go$pkg.ErrTrailingComma = errors.New("extra delimiter at end of line");
		go$pkg.ErrBareQuote = errors.New("bare \" in non-quoted-field");
		go$pkg.ErrQuote = errors.New("extraneous \" in field");
		go$pkg.ErrFieldCount = errors.New("wrong number of fields in line");
	};
